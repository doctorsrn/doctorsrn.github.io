<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/5_128.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/2_32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/1_16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/5_128.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="algorithm,robotics,matlab," />










<meta name="description" content="Reading NoteBook: Robotics, Vision and Control, Second EditionAuthor: Peter Corke公开课: The open online robotics education resource 摘录   Robots are data-driven machines. They acquire data, process it an">
<meta name="keywords" content="algorithm,robotics,matlab">
<meta property="og:type" content="article">
<meta property="og:title" content="Robotics, Vision and Control, Second Edition读书笔记">
<meta property="og:url" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/index.html">
<meta property="og:site_name" content="Hello World">
<meta property="og:description" content="Reading NoteBook: Robotics, Vision and Control, Second EditionAuthor: Peter Corke公开课: The open online robotics education resource 摘录   Robots are data-driven machines. They acquire data, process it an">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/2_0.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/2_1.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/2_2.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/2_3.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/2_4.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/2_5.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/2_6.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/2_7.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/2_8.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/3_1.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/3_2.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/3_3.png">
<meta property="og:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/7_1.png">
<meta property="og:updated_time" content="2018-10-08T15:34:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Robotics, Vision and Control, Second Edition读书笔记">
<meta name="twitter:description" content="Reading NoteBook: Robotics, Vision and Control, Second EditionAuthor: Peter Corke公开课: The open online robotics education resource 摘录   Robots are data-driven machines. They acquire data, process it an">
<meta name="twitter:image" content="http://doctorsrn.cn/2018/10/08/reading_note_rvc/pics/2_0.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://doctorsrn.cn/2018/10/08/reading_note_rvc/"/>





  <title>Robotics, Vision and Control, Second Edition读书笔记 | Hello World</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1dfa1c7ff6fb0549819d508771ae03c8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hello World</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://doctorsrn.cn/2018/10/08/reading_note_rvc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SamLiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://raw.githubusercontent.com/doctorsrn/git_test/master/050.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello World">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Robotics, Vision and Control, Second Edition读书笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-08T23:34:22+08:00">
                2018-10-08
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-10-08T23:34:22+08:00">
                2018-10-08
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/robotics/" itemprop="url" rel="index">
                    <span itemprop="name">robotics</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/08/reading_note_rvc/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/08/reading_note_rvc/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/08/reading_note_rvc/" class="leancloud_visitors" data-flag-title="Robotics, Vision and Control, Second Edition读书笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14,001 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  64 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Reading-Note"><a href="#Reading-Note" class="headerlink" title="Reading Note"></a>Reading Note</h1><p><strong>Book:</strong> <a href="https://link.springer.com/book/10.1007/978-3-642-20144-8" target="_blank" rel="noopener">Robotics, Vision and Control, Second Edition</a><br><strong>Author:</strong> <a href="http://petercorke.com/wordpress/" target="_blank" rel="noopener">Peter Corke</a><br><strong>公开课:</strong> <a href="https://robotacademy.net.au/" target="_blank" rel="noopener">The open online robotics education resource</a></p>
<p>摘录</p>
<blockquote>
<ul>
<li>Robots are data-driven machines. They acquire data, process it and take action based on it.  </li>
<li>instant gratification: 及时行乐  </li>
<li>Robot definition: a goal oriented machine that can sense, plan and act.  </li>
<li>Further Reading: The Handbook of Robotics (Siciliano and Khatib 2016)</li>
</ul>
</blockquote>
<a id="more"></a>
<p><strong>一个非常重要的问题</strong>：Matlab Robotics Toolbox中函数的参数涉及角度时使用的单位默认是弧度rad，但是在使用时发现实际情况是度deg，该问题的主要原因是调用的函数可能与MATLAB自带工具箱Phased Array System Toolbox中的函数重名导致的，比如rotx函数。所以可将该工具箱卸载来解决该问题。该问题可以参考<a href="https://petercorke.com/wordpress/toolboxes/faq" target="_blank" rel="noopener">Matlab Robotics Toolbox的官网</a>,其中有介绍“Toolbox is using degrees not radians”问题。</p>
<p>部分符号说明：<br><img src="./pics/2_0.png" alt="pic2_0"></p>
<h1 id="2-1-Working-in-Two-Dimensions-2D"><a href="#2-1-Working-in-Two-Dimensions-2D" class="headerlink" title="2.1 Working in Two Dimensions (2D)"></a>2.1 Working in Two Dimensions (2D)</h1><h2 id="2-1-1-Orientation-in-2-Dimensions"><a href="#2-1-1-Orientation-in-2-Dimensions" class="headerlink" title="2.1.1 Orientation in 2-Dimensions"></a>2.1.1 Orientation in 2-Dimensions</h2><h3 id="2-1-1-1-Orthonormal-Rotation-Matrix-正交旋转矩阵"><a href="#2-1-1-1-Orthonormal-Rotation-Matrix-正交旋转矩阵" class="headerlink" title="2.1.1.1 Orthonormal Rotation Matrix 正交旋转矩阵"></a>2.1.1.1 Orthonormal Rotation Matrix 正交旋转矩阵</h3><p>Y坐标系相对于X坐标系的正交旋转矩阵为：<br>$$ ^{X}R_{Y}(\theta) =<br>    \begin{pmatrix}<br>    cos(\theta)&amp; -sin(\theta)\<br>    sin(\theta)&amp; cos(\theta)<br>    \end{pmatrix}<br>$$</p>
<h3 id="2-1-1-2-Matrix-Exponential-矩阵指数"><a href="#2-1-1-2-Matrix-Exponential-矩阵指数" class="headerlink" title="2.1.1.2 Matrix Exponential 矩阵指数"></a>2.1.1.2 Matrix Exponential 矩阵指数</h3><p>矩阵指数存在的性质：<br>R = rot2($\theta$) 正交旋转矩阵<br>S = logm(R)<br>R = expm(S) 矩阵指数<br>S = skew($\theta$)<br>$\theta$ = vex(S)</p>
<h2 id="2-1-2-Pose-in-2-Dimensions"><a href="#2-1-2-Pose-in-2-Dimensions" class="headerlink" title="2.1.2 Pose in 2-Dimensions"></a>2.1.2 Pose in 2-Dimensions</h2><h3 id="2-1-2-1-Homogeneous-Transformation-Matrix-齐次变换矩阵"><a href="#2-1-2-1-Homogeneous-Transformation-Matrix-齐次变换矩阵" class="headerlink" title="2.1.2.1 Homogeneous Transformation Matrix 齐次变换矩阵"></a>2.1.2.1 Homogeneous Transformation Matrix 齐次变换矩阵</h3><p>从B坐标系到A坐标系的变换：<br>$$<br>    \begin{pmatrix}<br>    ^{A}x&amp; \<br>    ^{A}y&amp; \<br>    1&amp;<br>    \end{pmatrix}<br>    =<br>    \begin{pmatrix}<br>    ^{A}R<em>{B}&amp; t\<br>    0</em>{1\times2}&amp; 1<br>    \end{pmatrix}<br>    \begin{pmatrix}<br>    ^{B}x&amp; \<br>    ^{B}y&amp; \<br>    1&amp;<br>    \end{pmatrix}<br>$$<br>其中t=(x,y)。<br>引入齐次坐标，则上述变换可写为:<br>$$<br>^{A}\tilde{p} =<br>    \begin{pmatrix}<br>    ^{A}R<em>{B}&amp; t\<br>    0</em>{1\times2}&amp; 1<br>    \end{pmatrix} \,<br>    ^{B}\tilde{p} = \,<br>    ^{A}T<em>{B}\,^{B}\tilde{p}<br>$$<br>其中$^{A}T</em>{B}$是齐次变换矩阵。T的值为：<br>$$<br>T = \begin{pmatrix}<br>    cos(\theta)&amp; -sin(\theta)&amp; x\<br>    sin(\theta)&amp; cos(\theta)&amp; y \<br>    0&amp; 0&amp; 1<br>    \end{pmatrix}<br>$$<br>T的性质：<br>$$<br>T^{-1} = \begin{pmatrix}<br>    R&amp; t\<br>    0<em>{1\times2}&amp; 1<br>    \end{pmatrix}^{-1} =<br>    \begin{pmatrix}<br>    R^{T}&amp; -R^{T}t\<br>    0</em>{1\times2}&amp; 1<br>    \end{pmatrix}<br>$$</p>
<p>MATLAB相关命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T1 = transl2(1, 2) * trot2(30, &apos;deg&apos;)</span><br><span class="line">plotvol([0 5 0 5]);</span><br><span class="line">trplot2(T1, &apos;frame&apos;, &apos;1&apos;, &apos;color&apos;, &apos;b&apos;)</span><br><span class="line">T2 = transl2(2, 1)</span><br><span class="line">T3 = T1*T2</span><br><span class="line">trplot2(T2, &apos;frame&apos;, &apos;2&apos;, &apos;color&apos;, &apos;r&apos;);</span><br><span class="line">trplot2(T3, &apos;frame&apos;, &apos;3&apos;, &apos;color&apos;, &apos;g&apos;);</span><br><span class="line"></span><br><span class="line">T4 = T2*T1</span><br><span class="line">trplot2(T4, &apos;frame&apos;, &apos;4&apos;, &apos;color&apos;, &apos;c&apos;);</span><br></pre></td></tr></table></figure></p>
<p><img src="./pics/2_1.png" alt="pic2_1">  </p>
<p><strong>注意</strong>：T3和T4结果的差别说明，T1*T2表示，T2的变换是相对于T1坐标系进行的，所以3坐标系的原点不是(3,3)，而4坐标系的原点是(3,3)。</p>
<p>另一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P=[3;2]   %坐标(3,2)点</span><br><span class="line">plot_point(P, &apos;label&apos;, &apos;P&apos;, &apos;solid&apos;, &apos;ko&apos;);</span><br><span class="line"></span><br><span class="line">%求P点相对于坐标系1的坐标</span><br><span class="line">P1 =  inv(T1) * [P;1] %此处将P点写为齐次坐标的形式</span><br><span class="line">%使用e2h函数也可实现普通点到齐次坐标的变化，h2e反之，即：</span><br><span class="line">P1 = h2e(inv(T1) * e2h(P))</span><br></pre></td></tr></table></figure></p>
<h3 id="2-1-2-2-Centers-of-Rotation旋转中心"><a href="#2-1-2-2-Centers-of-Rotation旋转中心" class="headerlink" title="2.1.2.2 Centers of Rotation旋转中心"></a>2.1.2.2 Centers of Rotation旋转中心</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plotvol([-5 4 -1 5]);</span><br><span class="line">T0 = eye(3,3);</span><br><span class="line">trplot2(T0, &apos;frame&apos;, &apos;0&apos;);</span><br><span class="line">X = transl2(2, 3);</span><br><span class="line">trplot2(X, &apos;frame&apos;, &apos;X&apos;);</span><br><span class="line">R = trot2(2);</span><br><span class="line">trplot2(R*X, &apos;framelabel&apos;, &apos;RX&apos;, &apos;color&apos;, &apos;r&apos;);</span><br><span class="line">trplot2(X*R, &apos;framelabel&apos;, &apos;XR&apos;, &apos;color&apos;, &apos;r&apos;);</span><br><span class="line">C = [1 2]&apos;;</span><br><span class="line">plot_point(C, &apos;label&apos;, &apos; C&apos;, &apos;solid&apos;, &apos;ko&apos;)</span><br><span class="line">RC = transl2(C) * R * transl2(-C)</span><br><span class="line">trplot2(RC*X, &apos;framelabel&apos;, &apos;XC&apos;, &apos;color&apos;, &apos;r&apos;);</span><br></pre></td></tr></table></figure>
<p><img src="./pics/2_2.png" alt="pic2_2">  </p>
<p>R*X: 旋转中心是原始坐标原点<br>X*R: 旋转中心是X坐标系原点<br>以任意点为旋转中心对X旋转变换：transl2(C) <em> R </em> transl2(-C) * X</p>
<h3 id="2-1-2-3-Twists-in-2D"><a href="#2-1-2-3-Twists-in-2D" class="headerlink" title="2.1.2.3 Twists in 2D"></a>2.1.2.3 Twists in 2D</h3><ul>
<li><p>使用Twist类型进行旋转变换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%创建以C点为旋转中心的Twist，C=[1 2]&apos;</span><br><span class="line">tw = Twist(&apos;R&apos;, C)</span><br><span class="line"></span><br><span class="line">%获取以C点为旋转中心，旋转2 radians的变换矩阵</span><br><span class="line">%该结果与上一节RC = transl2(C) * R * transl2(-C)得到的结果一样</span><br><span class="line">T = tw.T(2)</span><br><span class="line"></span><br><span class="line">%从Twist得到旋转中心</span><br><span class="line">tw.pole()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Twist类型完成某方向上的平移变换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%沿(1,1)方向平移的Twist</span><br><span class="line">tw = Twist(&apos;T&apos;, [1 1])</span><br><span class="line"></span><br><span class="line">%平移√2</span><br><span class="line">tw.T(sqrt(2))</span><br></pre></td></tr></table></figure>
</li>
<li><p>更一般的变换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T = transl2(2, 3) * trot2(0.5)</span><br><span class="line"></span><br><span class="line">%计算Twist向量值</span><br><span class="line">tw = Twist(T)</span><br><span class="line"></span><br><span class="line">%得到T</span><br><span class="line">tw.T</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>#2.2 Working in Three Dimensions (3D)  </p>
<blockquote>
<p>Euler’s rotation theorem:<br>Any two independent orthonormal coordinate frames can be related by a sequence of rotations (not more than three) about coordinate axes, where no two successive rotations may be about the same axis.</p>
</blockquote>
<p><img src="./pics/2_3.png" alt="pic2_3"> </p>
<h2 id="2-2-1-Orientation-in-3-Dimensions"><a href="#2-2-1-Orientation-in-3-Dimensions" class="headerlink" title="2.2.1 Orientation in 3-Dimensions"></a>2.2.1 Orientation in 3-Dimensions</h2><h3 id="2-2-1-1-Orthonormal-Rotation-Matrix"><a href="#2-2-1-1-Orthonormal-Rotation-Matrix" class="headerlink" title="2.2.1.1 Orthonormal Rotation Matrix"></a>2.2.1.1 Orthonormal Rotation Matrix</h3><p>从B坐标系旋转至A坐标系：<br>$$<br>    \begin{pmatrix}<br>    ^{A}x&amp; \<br>    ^{A}y&amp; \<br>    ^{A}z&amp;<br>    \end{pmatrix}<br>    = \,<br>    ^{A}R_{B}<br>    \begin{pmatrix}<br>    ^{B}x&amp; \<br>    ^{B}y&amp; \<br>    ^{B}z&amp;<br>    \end{pmatrix}<br>$$</p>
<p>3维旋转矩阵的一些性质：</p>
<ul>
<li>正交性，每列是单位向量，且列与列之间是正交的</li>
<li>$R^{-1} = R^{T}$</li>
<li>正交旋转矩阵共9个元素，但是并不是彼此独立，各列是单位向量且彼此正交，提供6个约束条件，所以9个元素只有三个是独立的</li>
</ul>
<p>各个轴的正交旋转矩阵：<br>$$<br>R_{x}(\theta) = \begin{pmatrix}<br>                1&amp; 0&amp; 0\<br>                0&amp; cos(\theta)&amp; -sin(\theta)\<br>                0&amp; sin(\theta)&amp; cos(\theta)<br>                \end{pmatrix}<br>$$</p>
<p>$$<br>R_{y}(\theta) = \begin{pmatrix}<br>                cos(\theta)&amp; 0&amp; sin(\theta)\<br>                0&amp; 1&amp; 0\<br>                -sin(\theta)&amp; 0&amp; cos(\theta)<br>                \end{pmatrix}<br>$$</p>
<p>$$<br>R_{z}(\theta) = \begin{pmatrix}<br>                cos(\theta)&amp; -sin(\theta)&amp; 0 \<br>                sin(\theta)&amp; cos(\theta)&amp; 0\<br>                0&amp; 0&amp; 1<br>                \end{pmatrix}<br>$$</p>
<p>相关Matlab函数：</p>
<ul>
<li>rotx, roty, rotz (单位是deg)</li>
<li>可视化函数：trplot(R)， 动画tranimate(R)</li>
</ul>
<h3 id="2-2-1-2-Three-Angle-Representations"><a href="#2-2-1-2-Three-Angle-Representations" class="headerlink" title="2.2.1.2 Three- Angle Representations"></a>2.2.1.2 Three- Angle Representations</h3><p>根据Euler’s rotation theorem,有两类旋转方法：Eulerian and Cardanian  </p>
<ul>
<li>Eulerian type: XYX, XZX, YXY, YZY, ZXZ, or ZYZ</li>
<li>Cardanian type: XYZ, XZY, YZX, YXZ, ZXY, or ZYX</li>
</ul>
<h4 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h4><p>比如ZYZ序列：$R=R<em>{z}(\phi)R</em>{y}(\theta)R_{z}(\psi)$<br>其对应的欧拉角为：$\Gamma=(\phi,\theta,\psi)$<br>例如欧拉角$\Gamma=(0.1,0.2,0.3)$，其对应的ZYZ旋转矩阵为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R = rotz(0.1) * roty(0.2) * rotz(0.3);</span><br><span class="line"></span><br><span class="line">%更便捷的求法</span><br><span class="line">R = eul2r(0.1, 0.2, 0.3)</span><br></pre></td></tr></table></figure></p>
<p>逆问题从旋转矩阵求欧拉角：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gamma = tr2eul(R)</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>:当$\theta$角为负时，从旋转矩阵求出的欧拉角将和之前的值不一样，$\theta$将变为正值，$\phi,\psi$都将不同。这是因为从旋转矩阵到欧拉角的映射是不唯一的，且Matlab ToolBox中的函数总是返回正的$\theta$角。</p>
<h4 id="万向角"><a href="#万向角" class="headerlink" title="万向角"></a>万向角</h4><p>另一种常用的角度是Cardan angles(万向节角): roll, pitch and yaw.<br>常用序列为：ZYX or XYZ</p>
<ul>
<li>ZYX: $R=R<em>{z}(\theta</em>{y})R<em>{y}(\theta</em>{p})R<em>{x}(\theta</em>{r})$, 常用于船舶、汽车、航行器的姿态描述, X轴指向前进方向</li>
<li>XYZ: $R=R<em>{X}(\theta</em>{y})R<em>{y}(\theta</em>{p})R<em>{Z}(\theta</em>{r})$，常用于机械臂末端执行器，Z轴指向前方，X轴指向上或者下</li>
</ul>
<p>Matlab Toolbox默认ZYX序列，可使用’xyz’参数进行设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">R = rpy2r(0.1, 0.2, 0.3)</span><br><span class="line"></span><br><span class="line">%逆操作</span><br><span class="line">gamma = tr2rpy(R)</span><br><span class="line"></span><br><span class="line">%xyz序列</span><br><span class="line">R = rpy2r(0.1, 0.2, 0.3, &apos;xyz&apos;)</span><br><span class="line">gamma = tr2rpy(R, &apos;xyz&apos;)</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-1-3-Singularities-and-Gimbal-Lock-奇异点现象和万向节锁"><a href="#2-2-1-3-Singularities-and-Gimbal-Lock-奇异点现象和万向节锁" class="headerlink" title="2.2.1.3 Singularities and Gimbal Lock 奇异点现象和万向节锁"></a>2.2.1.3 Singularities and Gimbal Lock 奇异点现象和万向节锁</h3><p><img src="./pics/2_4.png" alt="pic2_4"><br>当两个连续轴对齐时，欧拉角和万向节角的表示方法都会出现奇异点现象，即只能表示两个轴的姿态，第三个轴的姿态无法表示，出现自由度丢失的情况。对于ZYZ形式的欧拉角，当$\theta = k\pi, k\in \mathbb{Z}$时出现奇异点；对于万向节角，当pitch角$\theta_{p}=\pm(2k+1)\frac{\pi}{2}$时出现奇异点。</p>
<h3 id="2-2-1-4-Two-Vector-Representation双向量表示法"><a href="#2-2-1-4-Two-Vector-Representation双向量表示法" class="headerlink" title="2.2.1.4 Two Vector Representation双向量表示法"></a>2.2.1.4 Two Vector Representation双向量表示法</h3><p>这种表示方法主要用于机械臂,考虑末端执行器坐标系为E，如下图</p>
<p><img src="./pics/2_5.png" alt="pic2_5"><br>设工具指向的方向为Z轴，其对应的方向向量命名为approach vector（z向矢量）,设为$\hat{a}=(a_x,a_y,a_z)$。设两指之间的指向为orientation vector（y向矢量）, 设为$\hat{o}=(o_x,o_y,o_z)$。使用$\hat{a},\hat{o}$已经足够得到旋转矩阵R：<br>$$<br>R = \begin{pmatrix}<br>    n_x&amp; o_x&amp; a_x \<br>    n_y&amp; o_y&amp; a_y\<br>    n_z&amp; o_z&amp; a_z<br>    \end{pmatrix}<br>$$<br>$\hat{n},\hat{o},\hat{a}$向量依次对应X,Y,Z轴。</p>
<ul>
<li><p>当$\hat{a},\hat{o}$正交时：$\hat{n} = \hat{a}\times\hat{o}$，$\hat{n}$称为normal vetor（x向矢量）。<br>Matlab对应指令：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1 0 0]&apos;;</span><br><span class="line">o = [0 1 0]&apos;;</span><br><span class="line">R = oa2r(o, a)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当$\hat{a},\hat{o}$不正交，$\hat{a},\hat{o}$也可以定义一个平面，并且可以计算出与该平面垂直的法向量$\hat{n}$,然后可以得到与$\hat{a},\hat{n}$正交的向量$\hat{o}’=\hat{a}\times\hat{n}$</p>
</li>
</ul>
<h3 id="2-2-1-5-Rotation-about-an-Arbitrary-Vector绕任意向量旋转"><a href="#2-2-1-5-Rotation-about-an-Arbitrary-Vector绕任意向量旋转" class="headerlink" title="2.2.1.5 Rotation about an Arbitrary Vector绕任意向量旋转"></a>2.2.1.5 Rotation about an Arbitrary Vector绕任意向量旋转</h3><p>任意朝向的两个坐标轴可以通过绕空间中某个轴旋转一次而重合。设旋转轴为向量v，旋转角为theta，Matlab实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">R = rpy2r(0.1 , 0.2, 0.3);</span><br><span class="line">[theta, v] = tr2angvec(R)</span><br><span class="line"></span><br><span class="line">%求R的特征值和特征向量</span><br><span class="line">[x,e] = eig(R)</span><br><span class="line"></span><br><span class="line">%通过R的特征值求取旋转角</span><br><span class="line">theta = angle(e(1,1))</span><br></pre></td></tr></table></figure></p>
<p>v和theta不唯一。同时旋转矩阵R的特征值和特征向量存在如下关系：<br>因为特征值和特征向量存在关系:$$Rv={\lambda}v$$<br>当$\lambda=1$,即特征值为1时：$$Rv=v$$<br>此时对应的特征向量v在旋转矩阵R的变换下不发生改变，即该特征向量就是旋转轴。一个正交旋转矩阵总有一个特征值$\lambda=1$,且另外两个特征值为共轭复数，满足$\lambda=cos\theta{\pm}isin\theta$，此处$\theta$就是旋转角。</p>
<p><strong>逆问题</strong>：从旋转角和转轴向量求解旋转矩阵,使用Rodrigues旋转公式：<br>$$<br>R=I<em>{3\times3}+sin{\theta}[\hat{v}]</em>{\times}+<br>(1-cos\theta)[\hat{v}]^{2}<em>{\times}<br>$$<br>此处$[\hat{v}]</em>{\times}$是偏斜对称矩阵。对应的Matlab实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%绕X轴旋转pi/2的旋转矩阵</span><br><span class="line">R = angvec2r(pi/2, [1 0 0])</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-1-6-Matrix-Exponentials矩阵指数"><a href="#2-2-1-6-Matrix-Exponentials矩阵指数" class="headerlink" title="2.2.1.6 Matrix Exponentials矩阵指数"></a>2.2.1.6 Matrix Exponentials矩阵指数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">R = rotx(0.3) </span><br><span class="line"></span><br><span class="line">%求解矩阵对数</span><br><span class="line">%结果是拥有两个元素的稀疏矩阵,大小为0.3</span><br><span class="line">S = logm(R)</span><br><span class="line"></span><br><span class="line">%S也是偏斜对称矩阵</span><br><span class="line">%vex结果的第一个元素为旋转角0.3，对应于X轴为旋转轴</span><br><span class="line">vex(S)&apos;</span><br><span class="line"></span><br><span class="line">%使用工具箱函数获取旋转角和旋转轴</span><br><span class="line">[th,w] = trlog(R)</span><br><span class="line"></span><br><span class="line">%矩阵对数函数logm的逆函数为矩阵指数函数expm</span><br><span class="line">%重新得到旋转矩阵</span><br><span class="line">expm(S)</span><br><span class="line"></span><br><span class="line">%所以以下两个命令等价</span><br><span class="line">R = rotx(0.3);</span><br><span class="line">R = expm( skew([1 0 0]) * 0.3 );</span><br></pre></td></tr></table></figure>
<p>绕任意轴旋转的情况可以写为：<br>$$<br>R = e^{\hat{[\omega]}_\times\theta}\in{SO<em>3}<br>$$<br>$\theta$是旋转角，$\hat{\omega}$是平行于旋转轴的单位向量,符号$[\bullet]</em>\times:\mathbb{R}^3\mapsto\mathbb{R}^{3\times3}$表示从一个向量到偏斜对称矩阵的映射。</p>
<h3 id="2-2-1-7-Unit-Quaternions单位四元数"><a href="#2-2-1-7-Unit-Quaternions单位四元数" class="headerlink" title="2.2.1.7 Unit Quaternions单位四元数"></a>2.2.1.7 Unit Quaternions单位四元数</h3><p>Quaternions定义:<br>$$<br>q=s+v<em>{\tiny1}i+v</em>{\tiny2}j+v_{\tiny3}k<br>$$</p>
<p>Unit Quaternions 满足:<br>$$<br>\left |q \right | =s^2+v^2<em>{1}+v^2</em>{2}+v^2_{3} =1<br>$$<br>可以看做是绕单位向量$\hat{v}$旋转$\theta$角,满足关系式:<br>$$<br>\mathring{q}=cos\frac{\theta}{2}&lt;\hat{v}sin\frac{\theta}{2}&gt;<br>$$</p>
<p>对应的Matlab实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%注意角度单位是度还是弧度</span><br><span class="line">q = UnitQuaternion( rpy2tr(0.1, 0.2, 0.3) )</span><br><span class="line"></span><br><span class="line">inv(q)</span><br><span class="line">q*inv(q)</span><br><span class="line">q.R</span><br><span class="line">q.plot()</span><br><span class="line"></span><br><span class="line">%借助四元数进行旋转变换</span><br><span class="line">q*[1 0 0]&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-2-Pose-in-3-Dimensions"><a href="#2-2-2-Pose-in-3-Dimensions" class="headerlink" title="2.2.2 Pose in 3-Dimensions"></a>2.2.2 Pose in 3-Dimensions</h2><h3 id="2-2-2-1-Homogeneous-Transformation-Matrix"><a href="#2-2-2-1-Homogeneous-Transformation-Matrix" class="headerlink" title="2.2.2.1 Homogeneous Transformation Matrix"></a>2.2.2.1 Homogeneous Transformation Matrix</h3><p>3维齐次变换矩阵与2维类似：<br>$$<br>    \begin{pmatrix}<br>    ^{A}x&amp; \<br>    ^{A}y&amp; \<br>    ^{A}z&amp; \<br>    1&amp;<br>    \end{pmatrix}<br>    =<br>    \begin{pmatrix}<br>    ^{A}R<em>{B}&amp; t\<br>    0</em>{1\times3}&amp; 1<br>    \end{pmatrix}<br>    \begin{pmatrix}<br>    ^{B}x&amp; \<br>    ^{B}y&amp; \<br>    ^{B}z&amp; \<br>    1&amp;<br>    \end{pmatrix}<br>$$</p>
<p>引入齐次坐标，则上述变换可写为:<br>$$<br>^{A}\tilde{p} =<br>    \begin{pmatrix}<br>    ^{A}R<em>{B}&amp; t\<br>    0</em>{1\times3}&amp; 1<br>    \end{pmatrix} \,<br>    ^{B}\tilde{p} = \,<br>    ^{A}T<em>{B}\,^{B}\tilde{p}<br>$$<br>$^{A}T</em>{B}$是4x4的齐次变换矩阵。</p>
<p>T的性质：<br>$$<br>T_1T_2 = \begin{pmatrix}<br>    R_1&amp; t<em>1\<br>    0</em>{1\times3}&amp; 1<br>    \end{pmatrix}<br>    \begin{pmatrix}<br>    R_2&amp; t<em>2\<br>    0</em>{1\times3}&amp; 1<br>    \end{pmatrix}=<br>    \begin{pmatrix}<br>    R_1R_2&amp; t_1+R_1t<em>2\<br>    0</em>{1\times3}&amp; 1<br>    \end{pmatrix}<br>$$</p>
<p>$$<br>T^{-1} = \begin{pmatrix}<br>    R&amp; t\<br>    0<em>{1\times3}&amp; 1<br>    \end{pmatrix}^{-1} =<br>    \begin{pmatrix}<br>    R^{T}&amp; -R^{T}t\<br>    0</em>{1\times3}&amp; 1<br>    \end{pmatrix}<br>$$</p>
<p>相关Matlab程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%注意角度单位问题</span><br><span class="line">T = transl(1, 0, 0) * trotx(pi/2) * transl(0, 1, 0)</span><br><span class="line">tranimate(T)</span><br><span class="line"></span><br><span class="line">%旋转矩阵求解</span><br><span class="line">t2r(T)</span><br><span class="line"></span><br><span class="line">%坐标变换部分，一个列向量</span><br><span class="line">transl(T)&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-2-2-Vector-Quaternion-Pair向量-四元数对"><a href="#2-2-2-2-Vector-Quaternion-Pair向量-四元数对" class="headerlink" title="2.2.2.2 Vector-Quaternion Pair向量-四元数对"></a>2.2.2.2 Vector-Quaternion Pair向量-四元数对</h3><p>位姿的简洁、实用表示方法是向量-四元数对：<br>$$<br>\xi \sim (t, \mathring{q})<br>$$<br>其中$t \in \mathbb{R}^3$是一个表征原坐标系与参考坐标系之间关系的向量，$\mathring{q} \in \mathbb{S}^3$表征原坐标系相对于参考坐标系的朝向。</p>
<p><strong>Note</strong>：这种方法Matlab Robotics Toolbox没有实现。</p>
<h3 id="2-2-2-3-Twists"><a href="#2-2-2-3-Twists" class="headerlink" title="2.2.2.3 Twists"></a>2.2.2.3 Twists</h3><p>在三维空间，刚体的任意运动等效于螺旋运动–绕着空间中某条线旋转的同时沿着该线移动。<br>定义3维向量对Twist表征螺旋运动，$s=(v,\omega) \in \mathbb{R}^6$。$\omega$表征旋转轴，$v$表征twist轴在空间中的位置和螺旋运动的俯仰角。</p>
<p>Matlab相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%初始化一个单位twist，且转轴为x轴</span><br><span class="line">tw = Twist(&apos;R&apos;, [1 0 0], [0 0 0])</span><br><span class="line">%绕x轴旋转0.3rad，等价于trotx(0.3)</span><br><span class="line">tw.T(0.3)</span><br><span class="line"></span><br><span class="line">%创建沿y轴平移的twist</span><br><span class="line">tw = Twist(&apos;T&apos;, [0 1 0])</span><br><span class="line">%平移2个单位</span><br><span class="line">tw.T(2)</span><br></pre></td></tr></table></figure></p>
<p>一个关于螺旋运动模型的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X = transl(3, 4, -4);</span><br><span class="line">angles = [0:0.3:15];</span><br><span class="line"></span><br><span class="line">%定义旋转轴</span><br><span class="line">tw = Twist(&apos;R&apos;, [0 0 1], [2 3 2], 0.5);</span><br><span class="line"></span><br><span class="line">%可视化</span><br><span class="line">tranimate( @(theta) tw.T(theta) * X, angles, &apos;length&apos;, 0.5, &apos;retain&apos;, &apos;rgb&apos;, &apos;notext&apos;);</span><br><span class="line"></span><br><span class="line">%获取旋转轴，并绘制出来</span><br><span class="line">L = tw.line</span><br><span class="line">L.plot(&apos;k:&apos;, &apos;LineWidth&apos;, 2)</span><br></pre></td></tr></table></figure></p>
<p>将任意齐次变换转换为非单位twist：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T = transl(1, 2, 3) * eul2tr(0.3, 0.4, 0.5);</span><br><span class="line">tw = Twist(T)</span><br><span class="line"></span><br><span class="line">%俯仰角</span><br><span class="line">tw.pitch</span><br><span class="line"></span><br><span class="line">%关于轴的旋转</span><br><span class="line">tw.theta</span><br><span class="line"></span><br><span class="line">%旋转轴上的一点</span><br><span class="line">tw.pole&apos;</span><br></pre></td></tr></table></figure></p>
<p>关于Twists的更多知识可参看该<a href="http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf" target="_blank" rel="noopener">书籍</a>和<a href="https://blog.csdn.net/YgritteSnow/article/details/70307765" target="_blank" rel="noopener">博客</a>。</p>
<h1 id="2-3-Advanced-Topics"><a href="#2-3-Advanced-Topics" class="headerlink" title="2.3 Advanced Topics"></a>2.3 Advanced Topics</h1><h2 id="2-3-1-Normalization"><a href="#2-3-1-Normalization" class="headerlink" title="2.3.1 Normalization"></a>2.3.1 Normalization</h2><p>矩阵或者四元数经过多次乘积运算会出翔精度丢失的问题，可以使用归一化的方法进行解决：</p>
<ul>
<li>针对旋转矩阵：<code>trnorm(R)</code></li>
<li>针对四元数：<code>q.unit()</code></li>
</ul>
<h2 id="2-3-2-Understanding-the-Exponential-Mapping"><a href="#2-3-2-Understanding-the-Exponential-Mapping" class="headerlink" title="2.3.2 Understanding the Exponential Mapping"></a>2.3.2 Understanding the Exponential Mapping</h2><p>本章讲解旋转矩阵(rotation matrices)、偏斜对称矩阵(skewsymmetric matrices)和矩阵指数(matrix exponentiation)之间的关系。  </p>
<hr>
<p>设一点P，其坐标向量为p，以角速度向量$\omega$旋转，$\omega$的方向即为转轴方向。若使P点旋转$\theta$角，则P点的线速度为:<br>$$<br>\dot{p} = \omega \times p<br>$$<br>将交叉积替换为偏斜对称矩阵和向量的积:<br>$$<br>\dot{p} = [\omega]<em>\times p<br>$$<br>对于上述方程的一阶形式(标量形式):<br>$$<br>\dot{x} = ax<br>$$<br>得一阶形式的解为：<br>$$<br>x(t) = e^{at}x(0)<br>$$<br>原方程的解为：<br>$$<br>p(t) = e^{[\omega]</em>{\times}t} p(0)<br>$$<br>当$\left | \omega \right | = 1$时，表示t秒之后旋转t rad。我们需要旋转$\theta$角，所以设置$t = \theta$，可得：<br>$$<br>p(\theta) = e^{[\hat{\omega}]<em>{\times}\theta} p(0)<br>$$<br>该方程表示$p(0)$被旋转至$p(\theta)$。一个矩阵对向量进行旋转，该矩阵即是旋转矩阵:<br>$$<br>R(\theta,\hat{\omega}) = e^{[\hat{\omega}]</em>{\times}\theta} \in \mathrm{SO(3)}<br>$$</p>
<hr>
<p>考虑一般情况下的旋转和平移运动:<br>$$<br>\dot{p} = [\omega]<em>\times p + v<br>$$<br>写为矩阵形式：<br>$$<br>\begin{pmatrix}<br>\dot{p} \<br>0<br>\end{pmatrix} = \begin{pmatrix}<br>                [\omega]</em>\times&amp; v\<br>                0&amp; 0<br>                \end{pmatrix}<br>                \begin{pmatrix}<br>                p\<br>                1<br>                \end{pmatrix}<br>$$</p>
<p>引入齐次坐标，上述方程写为：<br>$$<br>\dot{\tilde{p}} = \begin{pmatrix}<br>                [\omega]<em>\times&amp; v\<br>                0&amp; 0<br>                \end{pmatrix}<br>                \tilde{p}<br>                =\Sigma \tilde{p}<br>$$<br>其中$\Sigma$是4x4阶增广斜对称矩阵,可得其标量形式的解为：<br>$$<br>\tilde{p}(\theta) = e^{\Sigma\theta}\tilde{p}(0)<br>$$<br>可得齐次变换矩阵$T(\theta,\hat\omega,v)$为：<br>$$<br>T(\theta,\hat\omega,v) = e^{<br>                \begin{pmatrix}<br>                [\hat\omega]</em>\times&amp; v\<br>                0&amp; 0<br>                \end{pmatrix}<br>                \theta<br>                } \in \mathrm{SE(3)}<br>$$</p>
<hr>
<p>以上讲解旋转矩阵(rotation matrices)、偏斜对称矩阵(skewsymmetric matrices)和矩阵指数(matrix exponentiation)之间的关系，Matlab实现的函数为<code>expm</code>和<code>trexp</code>。</p>
<h2 id="2-3-4-Dual-Quaternions对偶四元数"><a href="#2-3-4-Dual-Quaternions对偶四元数" class="headerlink" title="2.3.4 Dual Quaternions对偶四元数"></a>2.3.4 Dual Quaternions对偶四元数</h2><p>常规四元数只能表示空间旋转，而对偶四元数可以表示空间任意旋转和平移的组合。</p>
<h2 id="2-3-5-Configuration-Space构型空间"><a href="#2-3-5-Configuration-Space构型空间" class="headerlink" title="2.3.5 Configuration Space构型空间"></a>2.3.5 Configuration Space构型空间</h2><p>构型空间又称为C空间(C-Space),是系统所有可能的状态或配置（configuration）的集合,包括：</p>
<ul>
<li>运动学：不考虑物理学时所有可能配置的几何形状</li>
<li>动力学：随时间推移，系统配置的演变</li>
</ul>
<p>每个自由度就是C空间的其中一维，同时C空间张成的空间受到障碍物、关节限制等因素的约束。<br>配置（configuration）是系统参数的最小集合，且该集合可以描述系统上的任意一个点的位置，又被称为广义坐标。配置空间中的任意一个点可以映射到工作空间中的一个点，反之不一定为真。</p>
<p>工作空间的维度小于配置空间：系统过驱动（冗余），比如蛇形机器人<br>工作空间的维度大于配置空间：系统欠驱动</p>
<p><a href="https://web.eecs.umich.edu/~ocj/courses/autorob/autorob_14_configuration_spaces.pdf" target="_blank" rel="noopener">更多关于构型空间资料。</a></p>
<h1 id="2-4-Using-the-Toolbox"><a href="#2-4-Using-the-Toolbox" class="headerlink" title="2.4 Using the Toolbox"></a>2.4 Using the Toolbox</h1><ul>
<li><p>Matlab Robotics Toolbox支持2维位姿表示的数据类型：<br><img src="./pics/2_6.png" alt="pic2_6"></p>
</li>
<li><p>Matlab Robotics Toolbox支持3维位姿表示的数据类型：<br><img src="./pics/2_7.png" alt="pic2_7"></p>
</li>
<li><p>表示位姿的不同方法间的变换<br><img src="./pics/2_8.png" alt="pic2_8"></p>
</li>
</ul>
<h1 id="Chapter-3-Time-and-Motion"><a href="#Chapter-3-Time-and-Motion" class="headerlink" title="Chapter 3 Time and Motion"></a>Chapter 3 Time and Motion</h1><h1 id="3-1-Time-Varying-Pose"><a href="#3-1-Time-Varying-Pose" class="headerlink" title="3.1 Time-Varying Pose"></a>3.1 Time-Varying Pose</h1><h2 id="3-1-1-Derivative-of-Pose"><a href="#3-1-1-Derivative-of-Pose" class="headerlink" title="3.1.1 Derivative of Pose"></a>3.1.1 Derivative of Pose</h2><p><strong>指数形势下位姿的导数</strong>：<br>表示坐标系朝向的方法有很多种，这里我们使用最方便的指数形式:<br>$$<br>^{A}\mathrm{R}<em>{B}(t) = e^{[^{A}\hat{\omega}(t)]</em>{\times}\theta(t)} \in \mathrm{SO(3)}<br>$$<br>$^{A}\hat{\omega}(t)$表示相对于A坐标系的旋转轴,转角为$\theta(t)$，$[\bullet]<em>{\times}$表示偏斜对称矩阵。<br>关于时间的导数：<br>$$<br>^{A}\dot{R}</em>{B}(t) = [^{A}\hat{\omega}(t)]<em>{\times} \dot{\theta} e^{[^{A}\hat{\omega}(t)]</em>{\times}\theta(t)} \in \mathbb{R^{3\times3}}<br>=[^{A}\hat{\omega}(t)]<em>{\times}\dot{\theta} \, ^{A}\mathrm{R}</em>{B}(t)<br>$$</p>
<p>令$^A\omega= \, ^{A}\hat{\omega}\dot{\theta}$，则$^A\omega$是相对于A坐标系的角速度,上述方程可重写为：<br>$$<br>^{A}\dot{R}<em>{B} = [^{A}\hat{\omega}]</em>\times \, ^{A}{R}_{B} \in \mathbb{R^{3\times3}}<br>$$</p>
<p>B坐标系下的角速度变换至A坐标系：<br>$$<br>^A\omega = \, ^AR_B \, ^B\omega<br>$$</p>
<hr>
<p><strong>齐次变换矩阵形式下位姿的导数</strong>：<br>位姿的齐次矩阵形式：<br>$$<br>\xi \sim\, ^AT<em>B = \begin{pmatrix}<br>                    ^{A}R</em>{B}&amp; ^At<em>B\<br>                    0</em>{1\times3}&amp; 1<br>                    \end{pmatrix}<br>$$<br>其导数形式为：<br>$$<br>\dot\xi \sim\, ^A\dot{T}<em>B = \begin{pmatrix}<br>                    ^{A}\dot{R}</em>{B}&amp; ^A\dot{t}<em>B\<br>                    0</em>{1\times3}&amp; 0<br>                    \end{pmatrix}<br>                    =\begin{pmatrix}<br>                    [^{A}{\omega}]<em>\times \,^{A}{R}</em>{B}&amp; ^A\dot{t}<em>B\<br>                    0</em>{1\times3}&amp; 0<br>                    \end{pmatrix}<br>$$</p>
<p>B坐标系相对于A坐标系的平移速度即线速度为：$v=^A\dot{t}_{B}$，B坐标系相对于A坐标系的角速度是$^A{\omega}<em>B$。将上述两个速度向量组合为一个空间速度向量：<br>$$<br>^{\tiny{A}}v</em>{\tiny{B}} = (^{\tiny{A}}v<em>{\tiny{B}}, ^{\tiny{A}}\omega</em>{\tiny{B}}) \in \mathbb{R^6}<br>$$<br>这就是坐标系B相对于坐标系A的瞬时速度。</p>
<h2 id="3-1-2-Transforming-Spatial-Velocities空间速度的变换"><a href="#3-1-2-Transforming-Spatial-Velocities空间速度的变换" class="headerlink" title="3.1.2 Transforming Spatial Velocities空间速度的变换"></a>3.1.2 Transforming Spatial Velocities空间速度的变换</h2><p>如下图，坐标系A是世界参考坐标系，坐标系B是运动物体坐标系:<br><img src="./pics/3_1.png" alt="pic3_1"><br>空间速度$^Av,\,^Bv,\,^Cv$之间的变换关系为：<br>$$<br>^Av = \begin{pmatrix}<br>    ^{A}R<em>{B}&amp; 0</em>{3\times3}\<br>    0<em>{3\times3}&amp; ^{A}R</em>{B}<br>    \end{pmatrix}<br>    {^Bv} =<br>    {^A\mathit{J}_B}{(^A\xi_B)}{^Bv}<br>$$</p>
<p>$$<br>^Cv = \begin{pmatrix}<br>    ^{C}R_{B}&amp; [^Ct<em>B]</em>{\times}{^{C}R<em>{B}}\<br>    0</em>{3\times3}&amp; ^{C}R_{B}<br>    \end{pmatrix}<br>    {^Bv} =<br>    Ad{(^C\xi_B)}{^Bv}<br>$$</p>
<h2 id="3-1-3-Incremental-Rotation旋转的增量"><a href="#3-1-3-Incremental-Rotation旋转的增量" class="headerlink" title="3.1.3 Incremental Rotation旋转的增量"></a>3.1.3 Incremental Rotation旋转的增量</h2><p>占位:smile:</p>
<h2 id="3-1-4-Incremental-Rigid-Body-Motion-刚体运动的增量"><a href="#3-1-4-Incremental-Rigid-Body-Motion-刚体运动的增量" class="headerlink" title="3.1.4 Incremental Rigid-Body Motion 刚体运动的增量"></a>3.1.4 Incremental Rigid-Body Motion 刚体运动的增量</h2><p>占位:smile:</p>
<h1 id="3-2-Accelerating-Bodies-and-Reference-Frames"><a href="#3-2-Accelerating-Bodies-and-Reference-Frames" class="headerlink" title="3.2 Accelerating Bodies and Reference Frames"></a>3.2 Accelerating Bodies and Reference Frames</h1><h2 id="3-2-1-Dynamics-of-Moving-Bodies动力学"><a href="#3-2-1-Dynamics-of-Moving-Bodies动力学" class="headerlink" title="3.2.1 Dynamics of Moving Bodies动力学"></a>3.2.1 Dynamics of Moving Bodies动力学</h2><p>占位:smile:</p>
<h2 id="3-2-2-Transforming-Forces-and-Torques力和力矩的变换"><a href="#3-2-2-Transforming-Forces-and-Torques力和力矩的变换" class="headerlink" title="3.2.2 Transforming Forces and Torques力和力矩的变换"></a>3.2.2 Transforming Forces and Torques力和力矩的变换</h2><p>占位:smile:<br>wrench:力螺旋</p>
<h2 id="3-2-3-Inertial-Reference-Frame惯性参考系"><a href="#3-2-3-Inertial-Reference-Frame惯性参考系" class="headerlink" title="3.2.3 Inertial Reference Frame惯性参考系"></a>3.2.3 Inertial Reference Frame惯性参考系</h2><p>占位:smile:</p>
<h1 id="3-3-Creating-Time-Varying-Pose"><a href="#3-3-Creating-Time-Varying-Pose" class="headerlink" title="3.3 Creating Time-Varying Pose"></a>3.3 Creating Time-Varying Pose</h1><ul>
<li>Path路径：空间曲线，从初始位姿到终时位姿</li>
<li>Trajectory轨迹：指定时间参数的路径(运动时间、速度、加速度等)，要求轨迹平滑</li>
</ul>
<p><strong>平滑</strong>：要求关于时间的前几阶导数是连续的，即要求速度、加速度、甚至加加速度是连续的。</p>
<h2 id="3-3-1-Smooth-One-Dimensional-Trajectories"><a href="#3-3-1-Smooth-One-Dimensional-Trajectories" class="headerlink" title="3.3.1 Smooth One-Dimensional Trajectories"></a>3.3.1 Smooth One-Dimensional Trajectories</h2><p>符合一维轨迹平滑要求的函数最常见的是多项式函数，比如五阶多项式函数：<br>$$<br>s(t)=At^5+Bt^4+Ct^3+Dt^2+Et+F, \, t \in [0,T]<br>$$</p>
<hr>
<p><strong>基于多项式函数的轨迹规划</strong></p>
<ul>
<li>Matlab函数：<code>tpoly()</code>，可指定初始时刻和终止时刻的参数  </li>
<li>存在的问题：最大速度区域较少，没有充分利用电机的能力，会使机械臂的运动时间变长  </li>
</ul>
<hr>
<p><strong>混合轨迹的规划</strong><br>为使最大速度的区域增大，可以使轨迹的某一段保持最大速度运动。</p>
<ul>
<li>Matlab函数：<code>lspb()</code>，可指定最大速度</li>
<li>缺点：速度是平滑的，但是加速度不平滑</li>
</ul>
<h2 id="3-3-2-Multi-Dimensional-Trajectories多维空间的轨迹规划"><a href="#3-3-2-Multi-Dimensional-Trajectories多维空间的轨迹规划" class="headerlink" title="3.3.2 Multi-Dimensional Trajectories多维空间的轨迹规划"></a>3.3.2 Multi-Dimensional Trajectories多维空间的轨迹规划</h2><ul>
<li>Matlab函数：<code>mtraj()</code>，使用示例：<code>q = mtraj(@lspb, [0 2], [1 -1], 50)</code></li>
</ul>
<h2 id="3-3-3-Multi-Segment-Trajectories多段轨迹"><a href="#3-3-3-Multi-Segment-Trajectories多段轨迹" class="headerlink" title="3.3.3 Multi-Segment Trajectories多段轨迹"></a>3.3.3 Multi-Segment Trajectories多段轨迹</h2><ul>
<li>Matlab函数：<code>mstraj()</code>,生成多段多轴轨迹</li>
</ul>
<h2 id="3-3-4-Interpolation-of-Orientation-in-3D"><a href="#3-3-4-Interpolation-of-Orientation-in-3D" class="headerlink" title="3.3.4 Interpolation of Orientation in 3D"></a>3.3.4 Interpolation of Orientation in 3D</h2><p><strong>通过rpy角进行插值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%SO3.Rz输入参数的单位是度，而不是弧度</span><br><span class="line">R0 = SO3.Rz(-10) * SO3.Ry(-10);</span><br><span class="line">R1 = SO3.Rz(10) * SO3.Ry(10);</span><br><span class="line"></span><br><span class="line">%.rpy的输出参数的单位是弧度</span><br><span class="line">rpy0 = R0.torpy(); rpy1 = R1.torpy();</span><br><span class="line">rpy = mtraj(@tpoly, rpy0, rpy1, 50);</span><br><span class="line"></span><br><span class="line">rpy = rad2deg(rpy)</span><br><span class="line"></span><br><span class="line">%SO3.rpy 输入参数rpy的默认单位是角度而不是弧度</span><br><span class="line">SO3.rpy(rpy). animate;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>通过单位四元数进行插值</strong><br>使用spherical linear interpolation（球面线性插值）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q0 = R0. UnitQuaternion; q1 = R1.UnitQuaternion;</span><br><span class="line">q = interp(q0, q1, 50);</span><br><span class="line">q.animate</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-4-1-Direction-of-Rotation"><a href="#3-3-4-1-Direction-of-Rotation" class="headerlink" title="3.3.4.1 Direction of Rotation"></a>3.3.4.1 Direction of Rotation</h3><p>不同方向的旋转即使都能到达目标点，但是角位移不一样。<br>Matlab程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%正常旋转，角位移较大</span><br><span class="line">q0 = UnitQuaternion.Rz(-2); q1 = UnitQuaternion.Rz(2);</span><br><span class="line">q = interp(q0, q1, 50);</span><br><span class="line">q.animate()</span><br><span class="line"></span><br><span class="line">%使用&apos;shortest&apos;参数，将选择最短路径</span><br><span class="line">q = interp(q0, q1, 50, &apos;shortest&apos;);</span><br><span class="line">q.animate()</span><br></pre></td></tr></table></figure></p>
<h2 id="3-3-5-Cartesian-Motion-in-3D"><a href="#3-3-5-Cartesian-Motion-in-3D" class="headerlink" title="3.3.5 Cartesian Motion in 3D"></a>3.3.5 Cartesian Motion in 3D</h2><p>通常要求SE(3)空间中的位姿之间的路径平滑，即位置和方向的变化都要求平滑。<br>Matlab程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n = 180/pi;</span><br><span class="line">T0 = SE3([0.4, 0.2, 0]) * SE3.rpy(0, 0, 3*n);</span><br><span class="line">T1 = SE3([-0.4, -0.2, 0.3]) * SE3.rpy(-pi/4*n, pi/4*n, -pi/2*n);</span><br><span class="line"></span><br><span class="line">Ts = interp(T0, T1, 50);</span><br><span class="line">Ts.animate</span><br><span class="line"></span><br><span class="line">%绘制位置坐标变换情况</span><br><span class="line">P = Ts.transl;</span><br><span class="line">plot(P);</span><br><span class="line"></span><br><span class="line">%绘制方向坐标变化情况</span><br><span class="line">rpy = Ts.torpy;</span><br><span class="line">plot(rpy);</span><br></pre></td></tr></table></figure></p>
<p><img src="./pics/3_2.png" alt="pic3_2"><br>从运行结果可知，位置坐标的变化是平滑且线性的，方向坐标的变化是平滑的。但是在起点和终点的速度和加速度不是连续的。<br><strong>interp函数</strong>：interp对两点之间的归一化路径进行插值，所以<code>Ts = interp(T0, T1, 0.5)</code>表示T0和T1之间路径的中点。  </p>
<p>如果使用多项式插值或者多段插值的方法就可以克服速度和加速度不连续的问题，使用方法为：<code>Ts = T0. interp(T1, lspb(0, 1, 50) )</code>，或者直接使用笛卡尔轨迹规划函数：<code>Ts = ctraj(T0, T1, 50)</code><br><img src="./pics/3_3.png" alt="pic3_3">  </p>
<h1 id="Part-III-Arm-Type-Robots"><a href="#Part-III-Arm-Type-Robots" class="headerlink" title="Part III Arm-Type Robots"></a>Part III Arm-Type Robots</h1><h1 id="7-1-Forward-Kinematics"><a href="#7-1-Forward-Kinematics" class="headerlink" title="7.1 Forward Kinematics"></a>7.1 Forward Kinematics</h1><p>从关节坐标系或者配置空间到末端执行器位姿的映射。  </p>
<h2 id="7-1-1-2-Dimensional-Planar-Robotic-Arms"><a href="#7-1-1-2-Dimensional-Planar-Robotic-Arms" class="headerlink" title="7.1.1 2-Dimensional (Planar) Robotic Arms"></a>7.1.1 2-Dimensional (Planar) Robotic Arms</h2><p><img src="./pics/7_1.png" alt="pic7_1"> </p>
<ul>
<li>图a的变换公式：<br>$$<br>\xi_E(q) = \mathcal{R}<em>z(q</em>{\tiny{1}}) \oplus \mathcal{T}<em>x(a</em>{\tiny{1}})<br>$$  </li>
<li><p>图b的变换公式：<br>$$<br>\xi_E(q) = \underbrace{\mathcal{R}<em>z(q</em>{\tiny{1}}) }_{joint1} \oplus \underbrace{\mathcal{T}<em>x(a</em>{\tiny{1}})}_{link1} \oplus \underbrace{\mathcal{R}<em>z(q</em>{\tiny{2}}) }_{joint2} \oplus \underbrace{\mathcal{T}<em>x(a</em>{\tiny{2}})}_{link2}<br>$$<br> 对应的Matlab仿真程序：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   import ETS2.*</span><br><span class="line">   a1 = 1; a2 = 1;</span><br><span class="line">   E = Rz(&apos;q1&apos;) * Tx(a1) * Rz(&apos;q2&apos;) * Tx(a2)</span><br><span class="line">   E.fkine( [30, 40], &apos;deg&apos;)</span><br><span class="line"></span><br><span class="line">   E.plot( [30, 40], &apos;deg&apos;)</span><br><span class="line">   E.teach</span><br><span class="line"></span><br><span class="line">   %关节类型</span><br><span class="line">   %R：表示铰链结构 P:表示滑杆结构</span><br><span class="line">   %返回RR</span><br><span class="line">   E.structure</span><br><span class="line">   ```  </span><br><span class="line">   这种两关节结构自由度为2，配置空间为：$\mathcal&#123;C&#125; = \mathbb&#123;S&#125;^1 \times \mathbb&#123;S&#125;^1$,可以到达的工作空间为$\mathcal&#123;T&#125; \subset \mathbb&#123;R&#125;^2$，对于工作空间$\mathcal&#123;T&#125; \subset \mathrm&#123;SE&#125;(2)$则无法完全到达。</span><br><span class="line">+ 图c的变换公式：</span><br><span class="line">$$</span><br><span class="line">\xi_E(q) = \underbrace&#123;\mathcal&#123;R&#125;_z(q_&#123;\tiny&#123;1&#125;&#125;) &#125;_&#123;joint1&#125; \oplus \underbrace&#123;\mathcal&#123;T&#125;_x(a_&#123;\tiny&#123;1&#125;&#125;)&#125;_&#123;link1&#125; \oplus \underbrace&#123;\mathcal&#123;T&#125;_x(q_&#123;\tiny&#123;2&#125;&#125;) &#125;_&#123;joint2&#125;</span><br><span class="line">$$</span><br><span class="line">   对应的Matlab仿真程序：</span><br></pre></td></tr></table></figure>
<p> import ETS2.<em><br> a1 = 1;<br> E = Rz(‘q1’) </em> Tx(a1) * Tx(‘q2’)</p>
<p> E.plot( [30, 40], ‘deg’)<br> E.teach</p>
<p> %关节类型<br> %R：表示铰链结构 P:表示滑杆结构<br> %返回RP<br> E.structure</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 三关节的平面机械臂变换公式：</span><br><span class="line">$$</span><br><span class="line">\xi_E(q) = \underbrace&#123;\mathcal&#123;R&#125;_z(q_&#123;\tiny&#123;1&#125;&#125;) &#125;_&#123;joint1&#125; \oplus \underbrace&#123;\mathcal&#123;T&#125;_x(a_&#123;\tiny&#123;1&#125;&#125;)&#125;_&#123;link1&#125; \oplus \underbrace&#123;\mathcal&#123;R&#125;_z(q_&#123;\tiny&#123;2&#125;&#125;) &#125;_&#123;joint2&#125; \oplus \underbrace&#123;\mathcal&#123;T&#125;_x(a_&#123;\tiny&#123;2&#125;&#125;)&#125;_&#123;link2&#125;  \oplus \underbrace&#123;\mathcal&#123;R&#125;_z(q_&#123;\tiny&#123;3&#125;&#125;) &#125;_&#123;joint3&#125; \oplus \underbrace&#123;\mathcal&#123;T&#125;_x(a_&#123;\tiny&#123;3&#125;&#125;)&#125;_&#123;link3&#125; </span><br><span class="line">$$</span><br><span class="line">   该结构的机械臂可以到达任务空间$\mathcal&#123;T&#125; \subset \mathrm&#123;SE&#125;(2)$中的任何点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 7.1.2 3-Dimensional Robotic Arms</span><br><span class="line">真正有用的机械臂它的工作空间应该是$\mathcal&#123;T&#125; \subset \mathrm&#123;SE&#125;(3)$，就是说机械臂末端执行器可以到达空间中的任意位置和姿态。  </span><br><span class="line"></span><br><span class="line">![pic7_2](./pics/7_2.png)</span><br><span class="line">如上图，使用PUMA560机械臂模型作为仿真对象，MATLAB中调用该模型的方法如下：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>%matlab 2018a<br>mdl_puma560<br>p560.teach<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对应的正运动学的变换公式为：</span><br><span class="line">$$</span><br><span class="line">\xi_E(q) = \mathcal&#123;T&#125;_z(L_&#123;\tiny&#123;1&#125;&#125;) \oplus \mathcal&#123;R&#125;_z(q_&#123;\tiny&#123;1&#125;&#125;) \oplus \mathcal&#123;R&#125;_y(q_&#123;\tiny&#123;2&#125;&#125;) \oplus \mathcal&#123;T&#125;_y(L_&#123;\tiny&#123;2&#125;&#125;) \oplus \mathcal&#123;T&#125;_z(L_&#123;\tiny&#123;3&#125;&#125;) \oplus \mathcal&#123;R&#125;_y(q_&#123;\tiny&#123;3&#125;&#125;) </span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">\oplus \mathcal&#123;T&#125;_x(L_&#123;\tiny&#123;4&#125;&#125;) \oplus \mathcal&#123;T&#125;_y(L_&#123;\tiny&#123;5&#125;&#125;) \oplus \mathcal&#123;T&#125;_z(L_&#123;\tiny&#123;6&#125;&#125;) \oplus \underbrace&#123;\mathcal&#123;R&#125;_z(q_&#123;\tiny&#123;4&#125;&#125;) \oplus \mathcal&#123;R&#125;_y(q_&#123;\tiny&#123;5&#125;&#125;) \oplus \mathcal&#123;R&#125;_z(q_&#123;\tiny&#123;6&#125;&#125;) &#125;_&#123;wrist&#125;</span><br><span class="line">$$  </span><br><span class="line">最后的腕部（wrist）使用欧拉角的ZYZ变换顺序。  </span><br><span class="line">相关的Matlab程序：</span><br></pre></td></tr></table></figure></p>
<p>import ETS3.<em><br>L1 = 0; L2 = -0.2337; L3 = 0.4318; L4 = 0.0203; L5 = 0.0837; L6 = 0.4318;<br>E3 = Tz(L1) </em> Rz(‘q1’) <em> Ry(‘q2’) </em> Ty(L2) <em> Tz(L3) </em> Ry(‘q3’)    </p>
<ul>
<li>Tx(L4) <em> Ty(L5) </em> Tz(L6) <em> Rz(‘q4’) </em> Ry(‘q5’) * Rz(‘q6’);</li>
</ul>
<p>%正向运动学<br>E3.fkine([0 0 0 0 0 0])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.1.2.1 Denavit-Hartenberg Parameters</span><br><span class="line">假设一个机械臂有N个关节，标号为1到N，则其有N+1个连杆，可以标号为0到N。所以关节j连接着连杆j-1和连杆j，同时连杆l连接着关节l和关节l+1。通常连杆0是机械臂的底座，是固定的；连杆N是机械臂的末端执行器。  </span><br><span class="line"></span><br><span class="line">D-H参数的定义：</span><br><span class="line">![pic7_3](./pics/7_3.png)</span><br><span class="line"></span><br><span class="line">D-H参数法通过定义两个相邻关节坐标轴之间的空间关系来表示机械臂连杆的几何结构。并且D-H参数在定义时，机械臂必须处于一个特殊的配置--the zero-angle configuration(零位)。  </span><br><span class="line">同时要求坐标系&#123;j&#125;连接在连杆j的远端，坐标系&#123;j&#125;的z轴与j+1关节轴对齐。如下图所示：  </span><br><span class="line">D-H参数图示：</span><br><span class="line">![pic7_4](./pics/7_4.png)</span><br><span class="line"></span><br><span class="line">从连杆坐标系 &#123;j-1&#125;到坐标系&#123;j&#125;的变换为:</span><br><span class="line">$$</span><br><span class="line">^&#123;j-1&#125;\xi_j(\theta_j,d_j,a_j,\alpha_j)= \mathcal&#123;R&#125;_z(\theta_&#123;\tiny&#123;j&#125;&#125;) \oplus \mathcal&#123;T&#125;_z(d_&#123;\tiny&#123;j&#125;&#125;) \oplus \mathcal&#123;T&#125;_x(a_&#123;\tiny&#123;j&#125;&#125;) \oplus \mathcal&#123;R&#125;_x(\alpha_&#123;\tiny&#123;j&#125;&#125;) </span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">写为齐次矩阵形式：</span><br><span class="line">$$</span><br><span class="line">^&#123;j-1&#125;A_j =  \begin&#123;pmatrix&#125;</span><br><span class="line">            cos\theta_j&amp; -sin\theta_jcos\alpha_j&amp;  sin\theta_jsin\alpha_j&amp; a_jcos\theta_j\\ </span><br><span class="line">            sin\theta_j&amp; cos\theta_jcos\alpha_j&amp; -cos\theta_jsin\alpha_j&amp; \alpha_jsin\theta_j\\</span><br><span class="line">            0&amp; sin\alpha_j&amp; cos\alpha_j&amp; d_j\\</span><br><span class="line">            0&amp; 0&amp; 0&amp; 1</span><br><span class="line">            \end&#123;pmatrix&#125; </span><br><span class="line">$$  </span><br><span class="line"></span><br><span class="line">**Note**:对于旋转关节(revolute joint)，$\theta_j$是随关节转动而变化的，$d_j$是常数;而对于平移型关节(prismatic joint)，$d_j$是变化的，$\theta_j$是固定不变的，且$\alpha_j = 0$。所以使用广义关节坐标系$q_j$统一表示revolute joint情况下的$\theta_j$和prismatic joint情况下的$d_j$。  </span><br><span class="line">对于N轴机械臂,广义关节坐标$q \in \mathcal&#123;C&#125;$，此处的$\mathcal&#123;C&#125; \in \mathbb&#123;R&#125;^N$就是关节空间或配置空间。</span><br><span class="line"></span><br><span class="line">相关Matlab程序：</span><br></pre></td></tr></table></figure></p>
<p>%创建一个revolution型关节<br>L = Revolute(‘a’, 1)</p>
<p>%q=0.5 进行变换<br>L.A(0.5)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">正向运动学是关节坐标的函数，简单来说就是由每个链接的相对姿势的决定的：</span><br><span class="line">$$</span><br><span class="line">^0\xi_N = \mathcal&#123;K&#125;(\mathbf&#123;q&#125;;\theta,\mathbf&#123;d&#125;,\mathbf&#123;a&#125;,\alpha, \sigma) = &#123;^0\xi_1&#125; \oplus &#123;^1\xi_2&#125; \cdots &#123;^&#123;N-1&#125;\xi_N&#125;</span><br><span class="line">$$</span><br><span class="line">上述公式中连杆0表示机器人的底座，通常$d_1=0$。  </span><br><span class="line"></span><br><span class="line">相关Matlab程序：</span><br></pre></td></tr></table></figure></p>
<p>%使用SerialLink搭建机械臂模型<br>robot = SerialLink( [ Revolute(‘a’, 1) Revolute(‘a’, 1) ], ‘name’, ‘my robot’)</p>
<p>%进行正运动学解算<br>robot.fkine([30 40], ‘deg’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 7.1.2.2 Product of Exponentials  </span><br><span class="line">使用指数积表示机械臂正运动学:</span><br><span class="line">$$</span><br><span class="line">\xi_E \sim &#123;^0T_E&#125; = e^&#123;[S_1]q_1&#125; \cdots e^&#123;[S_N]q_N&#125; &#123;^0T_E(0)&#125;</span><br><span class="line">$$</span><br><span class="line">此处的$&#123;^0T_E(0)&#125;$表示末端执行器在关节坐标全为0时的位姿。</span><br><span class="line"></span><br><span class="line">### 7.1.2.3 6-Axis Industrial Robot</span><br><span class="line">Puma560 6轴机器人模型的仿真示例：</span><br></pre></td></tr></table></figure></p>
<p>mdl_puma560</p>
<p>%绘制机械臂处于零位（zero angle）的模型图<br>p560.plot(qz)</p>
<p>%零位时的正运动学运算<br>TE = p560.fkine(qz)</p>
<p>%设置末端工具的位姿<br>p560.tool = SE3(0, 0, 0.2);</p>
<p>%设置机械臂底座的参数，默认全为零<br>%puma560有一个30-inch高的基座<br>p560.base = SE3(0, 0, 30*0.0254);</p>
<p>%再次进行正运动学运算<br>p560.fkine(qz)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 7.2 Inverse Kinematics</span><br><span class="line">逆运动学:</span><br><span class="line">$$</span><br><span class="line">\mathbf&#123;q&#125; = \mathcal&#123;K&#125;^&#123;-1&#125;(\xi)</span><br><span class="line">$$  </span><br><span class="line">可以使用两种方法来求解逆运动学：</span><br><span class="line">+ 封闭形式或解析解可以使用几何或代数方法确定。但随着关机数增多，封闭形式的解可能不存在。</span><br><span class="line">+ 迭代数值解</span><br><span class="line"></span><br><span class="line">## 7.2.1 2-Dimensional (Planar) Robotic Arms  </span><br><span class="line">使用一个两关节的平面机械臂进行逆运动学原理的说明。  </span><br><span class="line"></span><br><span class="line">### 7.2.1.1 Closed-Form Solution</span><br><span class="line">求解封闭解的Matlab程序：</span><br></pre></td></tr></table></figure></p>
<p>import ETS2.*<br>a1 = 1; a2 = 1;</p>
<p>E = Rz(‘q1’) <em> Tx(a1) </em> Rz(‘q2’) * Tx(a2)<br>syms q1 q2 real</p>
<p>%正运动学求解<br>TE = E.fkine( [q1, q2] )</p>
<p>%定义末端执行器的位姿<br>syms x y real</p>
<p>%TE.t = (x,y)<br>%第一个方程。在符号工具箱中‘=’表示赋值<br>% ‘==’表示相等<br>e1 = x == TE.t(1)</p>
<p>%第二个方程<br>e2 = y == TE.t(2)</p>
<p>%求解方程组<br>%得到的解有两组<br>[s1,s2] = solve( [e1 e2], [q1 q2] )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 7.2.1.2 Numerical Solution 数值解  </span><br><span class="line">可将逆运动学看成是优化问题--使正向运动学的解和目标位姿之间的误差最小化：</span><br><span class="line">$$</span><br><span class="line">\mathbf&#123;q&#125;^* = arg \mathop&#123;min&#125;\limits_&#123;q&#125; \left \| \mathcal&#123;K&#125;(\mathbf&#123;q&#125;) \ominus \xi^* \right \|</span><br><span class="line">$$  </span><br><span class="line">所以对于2连杆结构的平面机械臂,其误差函数为：</span><br><span class="line">$$</span><br><span class="line">E(q) = \left \| [\mathcal&#123;K&#125;(\mathbf&#123;q&#125;)]_t - (x^* \, y^*)^T \right \|</span><br><span class="line">$$  </span><br><span class="line">使用Matlab进行数值解求解：</span><br></pre></td></tr></table></figure></p>
<p>%初始化目标位置<br>pstar = [0.6; 0.7];</p>
<p>%数值解，只得到一组解，而解析解有两组<br>%q的初始值决定了所得到的解析解<br>q = fminsearch( @(q) norm( E.fkine(q).t - pstar ), [0 0] )</p>
<p>%测试求解结果<br>E.fkine(q).print<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 7.2.2 3-Dimensional Robotic Arms</span><br><span class="line">### 7.2.2.1 Closed-Form Solution</span><br><span class="line">六轴机械臂封闭解存在的必要条件是它是球形腕部结构。使用PUMA560的D-H参数模型进行原理说明（PUMA560是球形腕部结构）。  </span><br><span class="line">Matlab程序：</span><br></pre></td></tr></table></figure></p>
<p>mdl_puma560</p>
<p>%标称关节坐标nominal joint coordinates<br>qn</p>
<p>%正向运动学<br>T = p560.fkine(qn)</p>
<p>%使用ikine6s求解逆运动学的封闭解<br>%ikine6s函数会根据D-F判断是否满足封闭解的条件<br>qi = p560.ikine6s(T)</p>
<p>p560.fkine(qi)</p>
<p>%强制使用右手解模式,此时所得结果与qn一致<br>%ikine6s不同的求解模式：<br>%left or right handed ‘l’, ‘r’<br>%elbow up or down ‘u’, ‘d’<br>%wrist fl ipped or not fl ipped ‘f’, ‘n’<br>qi = p560.ikine6s(T, ‘ru’)</p>
<p>%逆解不存在<br>p560.ikine6s( SE3(3, 0, 0) )</p>
<p>%q5=0出现奇异点现象<br>q = [0 pi/4 pi 0.1 0 0.2];<br>p560.ikine6s(p560.fkine(q), ‘ru’)<br>q(4)+q(6)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可以发现使用ikine6s函数求得的逆解和qn不一样，但是qi的正运动学结果和qn一致:</span><br><span class="line">![pic7_5](./pics/7_5.png)  </span><br><span class="line">事实上有8组关节坐标其正运动学对应的末端执行器的位姿一致。但由于机械结构的限制和障碍物的存在，8组解并不是都能在物理上实现。同时也存在一些不可达位姿。  </span><br><span class="line">由于奇异点问题，有的位姿也是不可达的，因为轴的对齐使有效自由度减少(万向节锁定问题)。  </span><br><span class="line">对于PUMA560，当$q_5=0$，时关节4和6对齐。此时只要$q_4+q_5$的值不变，任意$q_4$、$q_5$的值对应的位姿一样。  </span><br><span class="line"></span><br><span class="line">### 7.2.2.2 Numerical Solution  </span><br><span class="line">对于非6关节和球形腕部结构的机械臂，可以使用迭代数值方法求解逆运动学解。Matlab中迭代数值求解函数为`ikine`。    </span><br><span class="line">Matlab程序：</span><br></pre></td></tr></table></figure></p>
<p>%标称关节坐标nominal joint coordinates<br>qn</p>
<p>T = p560.fkine(qn)<br>qi = p560.ikine(T)<br>p560.fkine(qi)</p>
<p>p560.plot(qi)</p>
<p>%给定关节角初始值，默认全为0<br>qi = p560.ikine(T, ‘q0’, [0 0 3 0 0 0])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**Note**:数值法ikine比解析法ikine6s运行慢，但是在解决机械臂奇异点问题和机械臂关节角个数不为6的情况时有很大的优势。  </span><br><span class="line"></span><br><span class="line">### 7.2.2.3 Under-Actuated Manipulator欠驱动机械臂</span><br><span class="line">关节数少于6的机械臂称为欠驱动机械臂，因为其末端执行器在空间中所能到达的位姿存在限制。通常情况下工作空间是$x-y-z-\theta$,即$\mathcal&#123;T&#125; \subset \mathbb&#123;R&#125;^3 \times \mathbb&#123;S&#125;^1$，配置空间是$\mathcal&#123;C&#125; \subset (\mathbb&#123;S&#125;^1)^3 \times \mathbb&#123;R&#125;$。   </span><br><span class="line">以SCARA Robot为例，这是一个RRPR型4轴机械臂:</span><br></pre></td></tr></table></figure></p>
<p>mdl_cobra600<br>c600</p>
<p>%注意RPY的单位，我的MATLAB默认是deg<br>%书中程序是：<br>%T = SE3(0.4, -0.3, 0.2) <em> SE3.rpy(30, 40, 160, ‘deg’)<br>T = SE3(0.4, -0.3, 0.2) </em> SE3.rpy(30, 40, 160)</p>
<p>%逆运动学求解，忽略x、y轴的旋转<br>q = c600.ikine(T, ‘mask’, [1 1 1 0 0 1])</p>
<p>Ta = c600.fkine(q);<br>Ta.print(‘xyz’)<br>trplot(T, ‘color’, ‘b’)<br>hold on<br>trplot(Ta, ‘color’, ‘r’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">![pic7_6](./pics/7_6.png) </span><br><span class="line">由于该型机械臂末端执行器的姿态只能以z-轴为旋转轴进行旋转，所以目标位姿T是过约束的，T沿x和y轴的旋转是无效的，所以使用ikine数值法求逆解时，使用&apos;mask&apos;参数将沿x和y轴的旋转进行忽略。最终求得的关节角q对应的末端执行器的位姿是满足该机械臂物理约束的，即末端执行器坐标系的z轴是垂直的。  </span><br><span class="line"></span><br><span class="line">### 7.2.2.4 Redundant Manipulator冗余机械臂</span><br><span class="line">关节数大于6的机械臂称为冗余机械臂。虽然理论上拥有6个关节的机械臂就可以到达笛卡尔工作空间的任意期望位姿，但实际上由于关节限制、奇异点等因素的存在，并不能完全实现到达任意位姿。所以添加更多的关节就是解决这个问题的一个办法，但是这又会导致关节坐标的解有无数个。为了解决关节坐标的解无数多的问题，需要引入约束条件，常用的约束是最小范数--返回的关节坐标向量解满足范数值最小。   </span><br><span class="line">以Baxter robot为例，该机器人有两个机械臂，且每个机械臂有7个关节。</span><br></pre></td></tr></table></figure></p>
<p>mdl_baxter</p>
<p>%左臂<br>left</p>
<p>TE = SE3(0.8, 0.2, -0.2) * SE3.Ry(pi);</p>
<p>%此时ikine获得的逆解关节坐标向量q满足范数最小<br>q = left.ikine(TE)</p>
<p>left.fkine(q).print(‘xyz’)<br>left.plot(q)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 7.3 Trajectories  </span><br><span class="line">对于机械臂最普遍的需求是可以将末端执行器从一个位姿平滑的移动至另一个位姿。常用的生成轨迹的两种方法是：在配置空间（也即关节空间）直线移动，或者在任务空间（也即笛卡尔空间）直线移动。    </span><br><span class="line"></span><br><span class="line">## 7.3.1 Joint-Space Motion 关节空间的运动</span><br><span class="line">Matlab仿真程序：</span><br></pre></td></tr></table></figure></p>
<p>mdl_puma560</p>
<p>T1 = SE3(0.4,  0.2, 0) <em> SE3.Rx(pi);<br>T2 = SE3(0.4, -0.2, 0) </em> SE3.Rx(pi/2);</p>
<p>q1 = p560.ikine6s(T1);<br>q2 = p560.ikine6s(T2);</p>
<p>%50 ms步长，2s内移动到<br>t = [0:0.05:2]’;</p>
<p>%借助mtraj函数生成轨迹<br>%使用tpoly插值<br>q = mtraj(@tpoly, q1, q2, t);</p>
<p>%使用lspb<br>q = mtraj(@lspb, q1, q2, t);</p>
<p>%或者使用将mtraj和tpoly封装的函数jtraj<br>%可获取速度和加速度：<br>%[q,qd,qdd] = jtraj(q1, q2, t);<br>q = jtraj(q1, q2, t);</p>
<p>%可使用类方法进行轨迹规划<br>q = p560.jtraj(T1, T2, t)</p>
<p>%可视化<br>p560.plot(q)<br>qplot(t, q); %绘制所有关节角的变化</p>
<p>%绘制笛卡尔空间的运动轨迹<br>T = p560.fkine(q);<br>p = T.transl;<br>plot(p(1,:), p(2,:))  %位置变化<br>plot(t, T.torpy(‘xyz’)) %姿态变化XYZ roll-pitch-yaw<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![pic7_7](./pics/7_7.png)  </span><br><span class="line">可以发现在关节空间的移动是平滑的。在笛卡尔空间末端执行器在x-y平面的移动轨迹不是直线，所以这是意料之中的，但这样移动可能导致碰撞，即使障碍物不在起始点和目标点之间。  </span><br><span class="line"></span><br><span class="line">## 7.3.2 Cartesian Motion 笛卡尔空间的运动  </span><br><span class="line">Matlab仿真程序：</span><br></pre></td></tr></table></figure></p>
<p>%使用ctraj函数<br>Ts = ctraj(T1, T2, length(t));</p>
<p>plot(t, Ts.transl);<br>plot(t, Ts.torpy(‘xyz’));</p>
<p>%关节空间的变化<br>qc = p560.ikine6s(Ts);<br>p560.plot(qc)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">![pic7_8](./pics/7_8.png)   </span><br><span class="line">与关节空间的运动相比：末端执行器在x-y平面沿直线运动，同时roll和pitch角在路径上恒为0度。  </span><br><span class="line"></span><br><span class="line">## 7.3.3 Kinematics in Simulink  </span><br><span class="line">使用simulink进行运动学仿真：`sl_jspace`  </span><br><span class="line"></span><br><span class="line">## 7.3.4 Motion through a Singularity  </span><br><span class="line">探究轨迹通过奇异点的运动：</span><br></pre></td></tr></table></figure></p>
<p>mdl_puma560</p>
<p>%z轴指向直接坐标系的x轴<br>T1 = SE3(0.5,  0.3, 0.44) <em> SE3.Ry(pi/2);<br>T2 = SE3(0.5, -0.3, 0.44) </em> SE3.Ry(pi/2);<br>t = [0:0.05:2]’;</p>
<p>%笛卡尔空间轨迹生成<br>Ts = ctraj(T1, T2, length(t));</p>
<p>%用解析解方法逆解算对应的关节角，对应图a<br>qc = p560.ikine6s(Ts);</p>
<p>%图d:qc的可操纵性<br>m = p560.maniplty(qc);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">![pic7_9](./pics/7_9.png)  </span><br><span class="line">对上面图片的分析：</span><br><span class="line">+ 从图a可以看到在$q_5$=0附近$q_4,q_6$变化剧烈，这是因为$q_5$接近0度时，$q_4,q_6$的旋转轴几乎平齐，发生万向节锁现象（也即奇异点）。关节轴对齐意味着机械臂丢失一个自由度，所以现在有效轴只有5轴（有效轴为5，实际关节角为6，相当于机械臂成为冗余机械臂），我们能确定的是$q_4+q_6$的和，而它们的具体取值有无数种。</span><br><span class="line">+ 图b是使用广义逆运动学方法ikine求解的结果，由于该方法会使用最小范数约束使$q_4,q_6$的范数值最小，同时满足$q_4+q_6$的和正确。</span><br><span class="line">+ 图c是这两个位姿在关节空间的运动，可以发现不存在奇异点问题，这是因为不涉及逆运动学过程。</span><br><span class="line">+ 图d是机械臂可操纵性（Manipulability）图：`m = p560.maniplty(qc)`。可操纵性：机械臂的灵活性，表征其在任意方向上容易移动的能力。是一个标量，可以计算轨迹上每个点的可操纵性值，越高越好。可以看到在奇异点附近可操纵性值接近0。可操纵性和广义逆运动学函数ikine都建立在机械臂Jacobian矩阵的基础上。  </span><br><span class="line"></span><br><span class="line">## 7.3.5 Configuration Change</span><br><span class="line">之前讨论过机械臂左右手工作方式和肘部向上向下工作方式。比如左右手工作方式的图解：</span><br><span class="line">![pic7_10](./pics/7_10.png) </span><br><span class="line">图片来自本书对应的公开课所对应的[Configuration change](https://www.bilibili.com/video/av27228968)章节。  </span><br><span class="line">如果从一个配置点运动至另一个配置点（比如从右手方式运动至左手方式），因为末端执行器对应的笛卡尔空间位姿一样，所以无法在笛卡尔空间进行轨迹规划，只能在关节空间进行轨迹规划。  </span><br><span class="line">Matlab示例程序：</span><br></pre></td></tr></table></figure></p>
<p>T = SE3(0.4, 0.2, 0) * SE3.Rx(pi);</p>
<p>qr = p560.ikine6s(T, ‘ru’);<br>ql = p560.ikine6s(T, ‘lu’);</p>
<p>%从右手工作方式到左手工作方式的轨迹规划<br>q = jtraj(qr, ql, t);</p>
<p>p560.plot(q)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 7.4 Advanced Topics</span><br><span class="line">## 7.4.1 Joint Angle Offsets  </span><br><span class="line">零度关节角位姿（zero joint angles）是机械臂设计者任意确定的,甚至可能是不可达的位姿。下图是PUMA560的零度关节角位姿，这样定义零度关节角位姿是为了方便确定标准D-H参数:</span><br><span class="line">![pic7_11](./pics/7_11.png)    </span><br><span class="line"></span><br><span class="line">而关节坐标偏移机制的存在可以任意设置零度关节坐标,设关节坐标偏移向量为$q_0$,则有：</span><br><span class="line">$$</span><br><span class="line">\xi_E = \mathcal&#123;K&#125;(\mathbf&#123;q&#125;+\mathbf&#123;q_0&#125;)</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">\mathbf&#123;q&#125; = \mathcal&#123;K&#125;^&#123;-1&#125;(\xi_E) -\mathbf&#123;q_0&#125;</span><br><span class="line">$$   </span><br><span class="line">Matlab中通过设置`Link`对象的offset属性或者`SerialLink`结构的&apos;offset&apos;选项来赋值。  </span><br><span class="line"></span><br><span class="line">## 7.4.2 Determining Denavit-Hartenberg Parameters</span><br><span class="line">确定D-H参数的经典方法是系统的为每个连杆分配一个坐标系，如PUMA560机械臂D-H参数的确定。但是这种方法设置每个坐标系时存在很强的局限性，因为关节必须绕z轴转动且连杆的移动必须沿着x轴方向，这又对基座和末端执行器的坐标系的放置施加了约束，并最终决定了零角度位姿。所以说确定一个D-H参数对应的连杆坐标系比确定D-H参数本身更难。    </span><br><span class="line">在Matlab Toolbox的支持下，一个可选的方法是：将机械臂简单描述为从基座到末端执行器的一系列基本的平移和旋转变换，其中有一些基本变换是恒定的，比如平移变换代表连杆的长度或者偏移，还有一些是广义关节坐标的函数。这种方法和之前所说的传统方法相比，对旋转或平移的轴没有进行约束。   </span><br><span class="line">以PUMA560为例，MATLAB程序：</span><br></pre></td></tr></table></figure></p>
<p>%使用string平移和旋转变换序列<br>s = ‘Tz(L1) Rz(q1) Ry(q2) Ty(L2) Tz(L3) Ry(q3) Tx(L4) Ty(L5)<br>Tz(L6) Rz(q4) Ry(q5) Rz(q6)’</p>
<p>%将string输入到字符代数函数<br>%该函数将机械臂的运动学结构分解为标准的D-H参数<br>dh = DHFactor(s);</p>
<p>%显示各个关节的D-H参数<br>dh</p>
<p>%使用得到的D-H参数生成对应的机械臂模型<br>%生成名为puma的机械臂模型对应的matlab命令<br>cmd = dh.command(‘puma’)</p>
<p>%执行上述生成的命令，生成机器人模型<br>robot = eval(cmd)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">可以看到上述程序在描述第二个关节时使用&quot;Ry(q2)&quot;，这在传统方法D-H形式主义中是不允许（D-H形式主义要求旋转必须绕z轴）。</span><br><span class="line"></span><br><span class="line">## 7.4.3 Modified Denavit-Hartenberg Parameters 改进型D-H参数  </span><br><span class="line">改进型D-H参数与普通的D-H参数相比：前者连杆坐标系连接到每个连杆的近端（近端）而不是远端（远端）。这种改进使符号在某些方面更加清晰和整洁。D-H参数的定义直接影响到运动学、Jacobian行列式和动力学算法。  </span><br><span class="line">改进型D-H参数约定的连杆见变换矩阵为：</span><br><span class="line">$$</span><br><span class="line">^&#123;j-1&#125;\xi_j(\alpha_&#123;j-1&#125;,a_&#123;j-1&#125;,d_j,\theta_j)= \mathcal&#123;R&#125;_x(\alpha_&#123;\tiny&#123;j-1&#125;&#125;) \oplus \mathcal&#123;T&#125;_x(a_&#123;\tiny&#123;j-1&#125;&#125;) \oplus \mathcal&#123;T&#125;_z(d_&#123;\tiny&#123;j&#125;&#125;) \oplus \mathcal&#123;R&#125;_z(\theta_&#123;\tiny&#123;j&#125;&#125;) </span><br><span class="line">$$</span><br><span class="line">改进型D-H参数坐标系定义图示：  </span><br><span class="line">![pic7_12](./pics/7_12.png)  </span><br><span class="line"></span><br><span class="line">**Note:** 使用论文中提供的D-H参数建立机器人模型时，首先需要确定该论文使用的是哪一种约定的参数表达方式。一般来说，表头是$\theta_j,d_j,a_j,\alpha_j$的是标准D-H参数形式，表头是$\theta_j,d_j,a_&#123;j-1&#125;,\alpha_&#123;j-1&#125;$的是改进型D-H参数。  </span><br><span class="line">在Matlab中使用`L1 = RevoluteMDH(&apos;d&apos;, 1)`来建立一个使用改进型D-H（MDH）参数的旋转铰链结构模型，然后就可以进一步建立完整的机械臂模型。  </span><br><span class="line">**标准D-H参数和改进型D-H参数的联系：**</span><br><span class="line">设标准D-H参数的表达式为：</span><br><span class="line">$$</span><br><span class="line">\underbrace&#123;\mathcal&#123;R&#125;_z(\theta_&#123;\tiny&#123;1&#125;&#125;) \oplus \mathcal&#123;T&#125;_z(d_&#123;\tiny&#123;1&#125;&#125;) \oplus \mathcal&#123;T&#125;_x(a_&#123;\tiny&#123;1&#125;&#125;) \oplus \mathcal&#123;R&#125;_x(\alpha_&#123;\tiny&#123;1&#125;&#125;)&#125;_&#123;DH_1&#125; \oplus  \underbrace&#123;\mathcal&#123;R&#125;_z(\theta_&#123;\tiny&#123;2&#125;&#125;) \oplus \mathcal&#123;T&#125;_z(d_&#123;\tiny&#123;2&#125;&#125;) \oplus \mathcal&#123;T&#125;_x(a_&#123;\tiny&#123;2&#125;&#125;) \oplus \mathcal&#123;R&#125;_x(\alpha_&#123;\tiny&#123;2&#125;&#125;)&#125;_&#123;DH_2&#125; \cdots </span><br><span class="line">$$  </span><br><span class="line">改进型D-H参数的表达式可由上式重写为：</span><br><span class="line">$$</span><br><span class="line">\underbrace&#123;\mathcal&#123;R&#125;_z(\theta_&#123;\tiny&#123;1&#125;&#125;) \oplus \mathcal&#123;T&#125;_z(d_&#123;\tiny&#123;1&#125;&#125;)&#125;_&#123;base&#125; \oplus \underbrace&#123; \mathcal&#123;T&#125;_x(a_&#123;\tiny&#123;1&#125;&#125;) \oplus \mathcal&#123;R&#125;_x(\alpha_&#123;\tiny&#123;1&#125;&#125;) \oplus  \mathcal&#123;R&#125;_z(\theta_&#123;\tiny&#123;2&#125;&#125;) \oplus \mathcal&#123;T&#125;_z(d_&#123;\tiny&#123;2&#125;&#125;)&#125;_&#123;MDH_1&#125; \oplus \underbrace&#123;\mathcal&#123;T&#125;_x(a_&#123;\tiny&#123;2&#125;&#125;) \oplus \mathcal&#123;R&#125;_x(\alpha_&#123;\tiny&#123;2&#125;&#125;) \cdots&#125;_&#123;MDH_2&#125; </span><br><span class="line">$$  </span><br><span class="line">其中$MDH_j$的形式与</span><br><span class="line">$$</span><br><span class="line">^&#123;j-1&#125;\xi_j(\alpha_&#123;j-1&#125;,a_&#123;j-1&#125;,d_j,\theta_j)= \mathcal&#123;R&#125;_x(\alpha_&#123;\tiny&#123;j-1&#125;&#125;) \oplus \mathcal&#123;T&#125;_x(a_&#123;\tiny&#123;j-1&#125;&#125;) \oplus \mathcal&#123;T&#125;_z(d_&#123;\tiny&#123;j&#125;&#125;) \oplus \mathcal&#123;R&#125;_z(\theta_&#123;\tiny&#123;j&#125;&#125;) </span><br><span class="line">$$</span><br><span class="line">是等价的，因为沿着同一个轴进行平移和旋转的变换是可以交换的,即满足：</span><br><span class="line">$$</span><br><span class="line">R_i(\theta)  \oplus T_i(d) = T_i(d) \oplus R_i(\theta), \, i \in \left \&#123; x,y,z \right \&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 7.5 Applications</span><br><span class="line">## 7.5.1 Writing on a Surface [examples/drawing.m]</span><br><span class="line">使用[Hershey font](http://paulbourke.net/dataformats/hershey/)作为字体输入数据。  </span><br><span class="line">Matlab程序：</span><br></pre></td></tr></table></figure></p>
<p>%载入hershy字体数据<br>load hershey</p>
<p>%载入‘B’的字体数据<br>B = hershey{‘B’};</p>
<p>%两行数据分别代表x,y轴的点，NaN表示分段点–起笔或落笔点<br>B.stroke</p>
<p>%将坐标乘以0.25，限制路径在0.85<em>0.25cm的范围内，，并添加z轴<br>%将Nan点替换为其上一时刻的坐标<br>path = [ 0.25</em>B.stroke; zeros(1,numcols(B.stroke))];<br>k = find(isnan(path(1,:)));<br>path(:,k) = path(:,k-1); path(3,k) = 0.2;</p>
<p>%使用mstraj进行多段轨迹规划，更多信息help mstraj查看<br>traj = mstraj(path(:,2:end)’, [0.5 0.5 0.5], [], path(:,1)’,    0.02, 0.2);</p>
<p>%得到路径的信息<br>about(traj)</p>
<p>%沿此路径移动的时间<br>numrows(traj) * 0.02</p>
<p>%将该轨迹可视化<br>plot3(traj(:,1), traj(:,2), traj(:,3))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过上面的程序得到的只是轨迹的位置序列，为了使用PUMA560绘制该轨迹，需要添加姿态信息，我们设置绘制平面为x-y平面(水平面)，其末端执行的z向矢量(approach vector)为$a=[0,0,-1]$,y向矢量(orientation vector)为$o=[0 1 0]$,同时将绘制的起点设为[0.6,0,0]，对应的Matlab程序为：</span><br></pre></td></tr></table></figure></p>
<p>Tp = SE3(0.6, 0, 0) <em> SE3(traj) </em> SE3.oa( [0 1 0], [0 0 -1]);<br>q = p560.ikine6s(Tp);</p>
<p>%设置显示轨迹<br> p560.plot(q, ‘trail’,{‘r’, ‘LineWidth’, 2})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此外也可以使用simulink模块进行绘制，步骤如下：</span><br><span class="line">+ 使用`sl_jspace`打开simulink示例模型，将其输入部分替换为**From Workspace**模块，按照该模块的配置要求在工作空间中设置好导入的数据。我们需要导入的是之前生成的轨迹对应的关节坐标序列q，按照**From Workspace**模块配置要求设置新变量：</span><br></pre></td></tr></table></figure></p>
<p>  qq.time = []<br>  qq.signals.values = q<br>  qq.signals.dimensions = 6;<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 整个simulink模型为：</span><br><span class="line">  ![pic7_13](./pics/7_13.png)</span><br><span class="line"></span><br><span class="line">+ **From Workspace**模块的具体设置为：</span><br><span class="line">  ![pic7_14](./pics/7_14.png)</span><br><span class="line"></span><br><span class="line">+ 运行模型。不同的字母绘制时间不同，所以要适当调整仿真时间，仿真结果：</span><br><span class="line">  ![pic7_15](./pics/7_15.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 7.5.2 A Simple Walking Robot [examples/walking.m]  </span><br><span class="line">本章搭建一个行走机器人。行走机器人的腿和机械臂类似，由于脚与地面有点接触且朝向重要，所以三关节串联结构足以满足要求。  </span><br><span class="line"></span><br><span class="line">### Kinematics    </span><br><span class="line">下图是行走机器人的零位示意图：</span><br><span class="line">![pic7_16](./pics/7_16.png)   </span><br><span class="line">第一个关节负责前后运动，旋转轴是z轴，旋转变换$R_z(q_1)$；第二个关节负责上下运动，旋转轴是x轴，旋转变换是$R_x(q_2)$；第三个关节式膝盖，负责远离或者靠近身体，旋转变换是$R_x(q_3)$。则从臀部至脚趾的变换序列是：</span><br><span class="line">$$</span><br><span class="line">\xi = R_z(q_1)R_x(q_2)T_y(L_1)R_x(q_3)T_z(L_2)</span><br><span class="line">$$  </span><br><span class="line">使用Matlab建立模型：</span><br></pre></td></tr></table></figure></p>
<p>s = ‘Rz(q1) Rx(q2) Ty(L1) Rx(q3) Tz(L2)’;</p>
<p>%得到标准D-H参数，最后三项为末端Tool朝向变换，无关紧要<br>dh = DHFactor(s)</p>
<p>%D-H后三项<br>dh.tool</p>
<p>%得到建立模型的MATLAB指令<br>dh.command(‘leg’)</p>
<p>%建立模型<br>L1 = 0.1; L2 = 0.1;<br>leg = eval( dh.command(‘leg’) )</p>
<p>%零位下脚的位置<br>transl( leg.fkine([0,0,0]) )</p>
<p>%可视化零位<br>leg.plot([0,0,0], ‘nobase’, ‘noshadow’, ‘notiles’)<br>set(gca, ‘Zdir’, ‘reverse’); view(137,48);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Motion of One Leg   </span><br><span class="line">接下来确定末端执行器--脚的移动路径。考虑行走机器人向前移动的过程：</span><br><span class="line">+ 所有脚以同样的速度向后移动，重置腿的位置--将脚抬起向前移动后放下，重复上述动作</span><br><span class="line">+ 为保持机器人的稳定，需要至少三只脚在地上，所以需要依次重置腿的位置</span><br><span class="line"> </span><br><span class="line">Matlab程序：</span><br></pre></td></tr></table></figure></p>
<p>%xf,xb是前后移动（沿x轴）的限制，单位mm<br>%y是脚和身体之间的距离（沿y轴）<br>%zu,zd是脚上下移动的相对高度（沿z轴）<br>xf = 50; xb = -xf; y = 50; zu = 20; zd = 50;</p>
<p>%得到路径<br>path = [xf y zd; xb y zd; xb y zu; xf y zu; xf y zd] * 1e-3;</p>
<p>%轨迹规划<br>p = mstraj(path, [], [0, 3, 0.25, 0.5, 0.25]’, path(1,:), 0.01, 0);</p>
<p>%使用逆运动学解算关节坐标<br>qcycle = leg.ikine( SE3(p), ‘mask’, [1 1 1 0 0 0] );</p>
<p>leg.plot(qcycle, ‘loop’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">脚移动时x，z轴的变化，以及四个脚再向前移动过程中x轴方向的位移图像：</span><br><span class="line">![pic7_17](./pics/7_17.png) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Motion of Four Legs  </span><br><span class="line">Matlab程序：</span><br></pre></td></tr></table></figure></p>
<p>W = 0.1; L = 0.2;</p>
<p>legs(1) = SerialLink(leg, ‘name’, ‘leg1’);<br>legs(2) = SerialLink(leg, ‘name’, ‘leg2’, ‘base’, SE3(-L, 0, 0));<br>legs(3) = SerialLink(leg, ‘name’, ‘leg3’, ‘base’, SE3(-L, -W, 0) <em> SE3.Rz(pi));<br>legs(4) = SerialLink(leg, ‘name’, ‘leg4’, ‘base’, SE3(0, -W, 0) </em> SE3.Rz(pi));</p>
<p>clf; k = 1;<br>while 1<br>legs(1).plot( gait(qcycle, k, 0, false) );<br>if k == 1, hold on; end<br>legs(2).plot( gait(qcycle, k, 100, false) );<br>legs(3).plot( gait(qcycle, k, 200, true) );<br>legs(4).plot( gait(qcycle, k, 300, true) );<br>drawnow<br>k = k+1;<br>end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">完整的Walking程序：</span><br></pre></td></tr></table></figure></p>
<p>%walking<br>clear all<br>L1 = 0.1; L2 = 0.1;</p>
<p>% create the leg links based on DH parameters<br>%                    theta   d     a  alpha<br>links(1) = Link([    0       0    0   pi/2 ], ‘standard’);<br>links(2) = Link([    0       0    L1   0   ], ‘standard’);<br>links(3) = Link([    0       0   -L2   0   ], ‘standard’);</p>
<p>% now create a robot to represent a single leg<br>leg = SerialLink(links, ‘name’, ‘leg’, ‘offset’, [pi/2   0  -pi/2]);</p>
<p>% define the key parameters of the gait trajectory, walking in the<br>% x-direction<br>xf = 5; xb = -xf;   % forward and backward limits for foot on ground<br>y = 5;              % distance of foot from body along y-axis<br>zu = 2; zd = 5;     % height of foot when up and down<br>% define the rectangular path taken by the foot<br>segments = [xf y zd; xb y zd; xb y zu; xf y zu] * 0.01;</p>
<p>% build the gait. the points are:<br>%   1 start of walking stroke<br>%   2 end of walking stroke<br>%   3 end of foot raise<br>%   4 foot raised and forward<br>%<br>% The segments times are :<br>%   1-&gt;2  3s<br>%   2-&gt;3  0.5s<br>%   3-&gt;4  1s<br>%   4-&gt;1  0.5ss<br>%<br>% A total of 4s, of which 3s is walking and 1s is reset.  At 0.01s sample<br>% time this is exactly 400 steps long.<br>%<br>% We use a finite acceleration time to get a nice smooth path, which means<br>% that the foot never actually goes through any of these points.  This<br>% makes setting the initial robot pose and velocity difficult.<br>%<br>% Intead we create a longer cyclic path: 1, 2, 3, 4, 1, 2, 3, 4. The<br>% first 1-&gt;2 segment includes the initial ramp up, and the final 3-&gt;4<br>% has the slow down.  However the middle 2-&gt;3-&gt;4-&gt;1 is smooth cyclic<br>% motion so we “cut it out” and use it.<br>segments = [0 0 0;segments; segments];<br>tseg = [3 0.25 0.5 0.25]’;<br>tseg = [1;tseg; tseg];<br>x = mstraj(segments, [], tseg, segments(1,:), 0.01, 0.1);</p>
<p>% pull out the cycle<br>xcycle = x(100:500,:);<br>qcycle = leg.ikine( transl(xcycle), ‘mask’, [1 1 1 0 0 0] );</p>
<p>% dimensions of the robot’s rectangular body, width and height, the legs<br>% are at each corner.<br>W = 0.1; L = 0.2;</p>
<p>% a bit of optimization.  We use a lot of plotting options to<br>% make the animation fast: turn off annotations like wrist axes, ground<br>% shadow, joint axes, no smooth shading.  Rather than parse the switches<br>% each cycle we pre-digest them here into a plotopt struct.<br>% plotopt = leg.plot({‘noraise’, ‘nobase’, ‘noshadow’, …<br>%     ‘nowrist’, ‘nojaxes’});<br>% plotopt = leg.plot({‘noraise’, ‘norender’, ‘nobase’, ‘noshadow’, …<br>%     ‘nowrist’, ‘nojaxes’, ‘ortho’});</p>
<p>plotopt = {‘noraise’, ‘nobase’, ‘noshadow’, ‘nowrist’, ‘nojaxes’, ‘delay’, 0};</p>
<p>% create 4 leg robots.  Each is a clone of the leg robot we built above,<br>% has a unique name, and a base transform to represent it’s position<br>% on the body of the walking robot.<br>legs(1) = SerialLink(leg, ‘name’, ‘leg1’);<br>legs(2) = SerialLink(leg, ‘name’, ‘leg2’, ‘base’, transl(-L, 0, 0));<br>legs(3) = SerialLink(leg, ‘name’, ‘leg3’, ‘base’, transl(-L, -W, 0)<em>trotz(pi));<br>legs(4) = SerialLink(leg, ‘name’, ‘leg4’, ‘base’, transl(0, -W, 0)</em>trotz(pi));</p>
<p>% create a fixed size axis for the robot, and set z positive downward<br>clf; axis([-0.3 0.1 -0.2 0.2 -0.15 0.05]); set(gca,’Zdir’, ‘reverse’)<br>hold on<br>% draw the robot’s body<br>patch([0 -L -L 0], [0 0 -W -W], [0 0 0 0], …<br>    ‘FaceColor’, ‘r’, ‘FaceAlpha’, 0.5)<br>% instantiate each robot in the axes<br>for i=1:4<br>    legs(i).plot(qcycle(1,:), plotopt{:});<br>end<br>hold off</p>
<p>% walk!<br>k = 1;<br>%A = Animate(‘walking’);<br>%while 1<br>for i=1:500<br>    legs(1).animate( gait(qcycle, k, 0,   0));<br>    legs(2).animate( gait(qcycle, k, 100, 0));<br>    legs(3).animate( gait(qcycle, k, 200, 1));<br>    legs(4).animate( gait(qcycle, k, 300, 1));<br>    drawnow<br>    k = k+1;<br>    %A.add();<br>end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 8 Manipulator Velocity  </span><br><span class="line">末端执行器的速度（平移和旋转速度）是各个关节速度合成的结果。本章介绍机械臂末端执行器的空间速度和关节速度之间的关系。关节变化率和末端执行器的速度是通过机械臂雅克比矩阵联系起来，机械臂雅克比矩阵是其配置的函数。  </span><br><span class="line"></span><br><span class="line"># 8.1 Manipulator Jacobian</span><br><span class="line">## 8.1.1 Jacobian in the World Coordinate Frame  </span><br><span class="line">以平面2关节机械臂为例.</span><br><span class="line">![pic8_1](./pics/8_1.png)</span><br></pre></td></tr></table></figure></p>
<p>%导入2关节机械臂模型<br>mdl_planar2_sym<br>syms q1 q2 real<br>TE = p2.fkine( [q1 q2] );<br>p = TE.t; p = p(1:2)</p>
<p>%求末端执行器位置向量的雅克比矩阵<br>J = jacobian(p, [q1 q2])<br><code>``   
所求的雅克比矩阵设为$J(q)$，满足：
$$
\frac{dp}{dq}=J(q)
$$  
由上述公式得：  
$$
\frac{dp}{dt}=J(q)\frac{dq}{dt}
$$  
即$$
\dot{p}=J(q)\dot{q}
$$  
所以雅克比矩阵将速度从关节坐标（配置空间）映射至末端执行器的笛卡尔坐标空间，同时雅克比矩阵是关节坐标的函数。  
类似于正向运动学$^0\xi=\mathcal{K}(q)$,我们可以写成：
$$
^0v={^0J(q)}\dot{q} 
$$  
此处的$^0v$是世界坐标系下的空间速度，即$^0v=(v_x,v_y,v_z,\omega_x,\omega_y,\omega_z) \in \mathbb{R}^6$。  
MATLAB中可使用**SerialLink**对象的</code>jacob0<code>方法求取雅克比矩阵的数值解：</code>J = p560.jacob0(qn)`。求得的雅克比矩阵维度是$dim \mathcal{T} \times dim \mathcal{C}$,此处是6x6。每一行表示笛卡尔空间自由度，每一列对应一个关节，该关节的单位速度用于合成末端执行器的空间速度。   </p>
<h2 id="8-1-2-Jacobian-in-the-End-Effector-Coordinate-Frame"><a href="#8-1-2-Jacobian-in-the-End-Effector-Coordinate-Frame" class="headerlink" title="8.1.2 Jacobian in the End-Effector Coordinate Frame"></a>8.1.2 Jacobian in the End-Effector Coordinate Frame</h2><p>通过<code>jacob0</code>求得的雅克比矩阵表示在世界坐标系下从关节速度到末端执行器空间速度的映射。而在末端执行器坐标系下的空间速度满足：<br>$$<br>^Ev= {^EJ_0}(^E\xi<em>0){^0J(q)}\dot{q}= \underbrace{<br>    \begin {pmatrix}<br>    ^{E}R</em>{0}&amp; 0<em>{3\times3}\<br>    0</em>{3\times3}&amp; ^{E}R<em>{0}<br>    \end{pmatrix}<br>    {^0J(q)}<br>    }</em>{}\dot{q} =<br>    {^EJ(q)}\dot{q}<br>$$<br>Matlab中使用<code>jacobe</code>求末端执行器坐标系下的雅克比矩阵:<code>p560.jacobe(qn)</code></p>
<h2 id="8-1-3-Analytical-Jacobian"><a href="#8-1-3-Analytical-Jacobian" class="headerlink" title="8.1.3 Analytical Jacobian"></a>8.1.3 Analytical Jacobian</h2><p>公式<br>$$<br>^0v={^0J(q)}\dot{q}<br>$$<br>中$^0v$是以平移和角速度向量表示的空间速度，用角速度表示旋转速度不直观，所以常用roll-pitch-yaw角或欧拉角的变化率来表示旋转速度。常用三角速率形式的解析式雅克比来表示旋转速度。<br>以XYZ形式的roll-pitch-yaw角$\Gamma=(\theta_r,\theta_p,\theta_y)$为例，旋转变换为：<br>$$<br>R=R_x(\theta_r) R_y(\theta_p) R_z(\theta_y) =<br>    \begin {pmatrix}<br>    c\theta_p c\theta_r&amp; -c\theta_p s\theta_r&amp; s\theta_p\<br>    c\theta_y s\theta_r+c\theta_r s\theta_p s\theta_y&amp; -s\theta_p s\theta_y s\theta_r+c\theta_y c\theta_r&amp; -c\theta_p s\theta_y\<br>    s\theta_y s\theta_r-c\theta_y c\theta_r s\theta_p&amp; c\theta_y s\theta_p s\theta_r+c\theta_r s\theta_y&amp; c\theta_p c\theta<em>y<br>    \end{pmatrix}<br>$$<br>由上式可得R的微分:<br>$$<br>\dot{R} = [\omega]</em>{\times}R<br>$$<br>可以以roll-pitch-yaw角形式解出$\omega$：<br>$$<br>\begin {pmatrix}<br>\omega_x\<br>\omega_y\<br>\omega_z<br>\end{pmatrix} =\begin {pmatrix}<br>s\theta_p\dot{\theta_r}+\dot{\theta_y} \<br>-c\theta_p s\theta_y \dot{\theta_r} + c\theta_y\dot{\theta_p}\<br>c\theta_p c\theta_y \dot{\theta_r} + s\theta_y \dot{\theta_p}<br>\end{pmatrix}<br>$$<br>可以因式分解为：<br>$$<br>\omega =\begin {pmatrix}<br>            s\theta_p&amp; 0&amp; 1\<br>            -c\theta_p s\theta_y&amp; c\theta_y&amp; 0\<br>            c\theta_p c\theta_y&amp; s\theta_y&amp; 0<br>        \end{pmatrix}<br>        \begin {pmatrix}<br>        \dot{\theta_r}\<br>        \dot{\theta_p}\<br>        \dot{\theta_r}<br>        \end{pmatrix}<br>$$<br>进一步可以写为：<br>$$<br>\omega = A(\Gamma)\dot{\Gamma}<br>$$<br>其中矩阵A就是雅克比矩阵，表示从XYZ roll-pitch-yaw角到角速度的映射,当$cos\phi=0$或者pitch角$\phi<br>=\pm\frac{\pi}{2}$时会出现奇异点。对应的MATLAB实现为：<code>rpy2jac(0.1, 0.2, 0.3)</code>。同样可以使用欧拉角形式的雅克比矩阵，对应的MATLAB函数为：<code>eul2jac</code>。对于PUMA560的求解为：<code>p560.jacob0(qn, &#39;eul&#39;)</code>。   </p>
<h1 id="8-2-Jacobian-Condition-and-Manipulability雅克比条件和可操纵性"><a href="#8-2-Jacobian-Condition-and-Manipulability雅克比条件和可操纵性" class="headerlink" title="8.2 Jacobian Condition and Manipulability雅克比条件和可操纵性"></a>8.2 Jacobian Condition and Manipulability雅克比条件和可操纵性</h1><p>页内跳转：<br>锚点：<span id="jump">Hello World</span><br>跳转：<a href="#jump">XXXX</a></p>

      
    </div>
    
    
    
    
    <div>
     
       <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------The End<i class="fa fa-paw"></i>Thanks for reading!-------------</div>
    
</div>

     
    </div>     


    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    SamLiu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://doctorsrn.cn/2018/10/08/reading_note_rvc/" title="Robotics, Vision and Control, Second Edition读书笔记">http://doctorsrn.cn/2018/10/08/reading_note_rvc/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/algorithm/" rel="tag"><i class="fa fa-tag"></i> algorithm</a>
          
            <a href="/tags/robotics/" rel="tag"><i class="fa fa-tag"></i> robotics</a>
          
            <a href="/tags/matlab/" rel="tag"><i class="fa fa-tag"></i> matlab</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/22/hw/" rel="next" title="华为软件精英挑战赛">
                <i class="fa fa-chevron-left"></i> 华为软件精英挑战赛
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://raw.githubusercontent.com/doctorsrn/git_test/master/050.jpg"
                alt="SamLiu" />
            
              <p class="site-author-name" itemprop="name">SamLiu</p>
              <p class="site-description motion-element" itemprop="description">Valar Morghulis!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/doctorsrn" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Reading-Note"><span class="nav-number">1.</span> <span class="nav-text">Reading Note</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-1-Working-in-Two-Dimensions-2D"><span class="nav-number">2.</span> <span class="nav-text">2.1 Working in Two Dimensions (2D)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-1-Orientation-in-2-Dimensions"><span class="nav-number">2.1.</span> <span class="nav-text">2.1.1 Orientation in 2-Dimensions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-1-Orthonormal-Rotation-Matrix-正交旋转矩阵"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1.1 Orthonormal Rotation Matrix 正交旋转矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-2-Matrix-Exponential-矩阵指数"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.1.2 Matrix Exponential 矩阵指数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-2-Pose-in-2-Dimensions"><span class="nav-number">2.2.</span> <span class="nav-text">2.1.2 Pose in 2-Dimensions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-1-Homogeneous-Transformation-Matrix-齐次变换矩阵"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1.2.1 Homogeneous Transformation Matrix 齐次变换矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-2-Centers-of-Rotation旋转中心"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.1.2.2 Centers of Rotation旋转中心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-3-Twists-in-2D"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.1.2.3 Twists in 2D</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-1-Orientation-in-3-Dimensions"><span class="nav-number">2.3.</span> <span class="nav-text">2.2.1 Orientation in 3-Dimensions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-1-Orthonormal-Rotation-Matrix"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.2.1.1 Orthonormal Rotation Matrix</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-2-Three-Angle-Representations"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.2.1.2 Three- Angle Representations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#欧拉角"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">欧拉角</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#万向角"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">万向角</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-3-Singularities-and-Gimbal-Lock-奇异点现象和万向节锁"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.2.1.3 Singularities and Gimbal Lock 奇异点现象和万向节锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-4-Two-Vector-Representation双向量表示法"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.2.1.4 Two Vector Representation双向量表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-5-Rotation-about-an-Arbitrary-Vector绕任意向量旋转"><span class="nav-number">2.3.5.</span> <span class="nav-text">2.2.1.5 Rotation about an Arbitrary Vector绕任意向量旋转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-6-Matrix-Exponentials矩阵指数"><span class="nav-number">2.3.6.</span> <span class="nav-text">2.2.1.6 Matrix Exponentials矩阵指数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-7-Unit-Quaternions单位四元数"><span class="nav-number">2.3.7.</span> <span class="nav-text">2.2.1.7 Unit Quaternions单位四元数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-2-Pose-in-3-Dimensions"><span class="nav-number">2.4.</span> <span class="nav-text">2.2.2 Pose in 3-Dimensions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-1-Homogeneous-Transformation-Matrix"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.2.2.1 Homogeneous Transformation Matrix</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-2-Vector-Quaternion-Pair向量-四元数对"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.2.2.2 Vector-Quaternion Pair向量-四元数对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-3-Twists"><span class="nav-number">2.4.3.</span> <span class="nav-text">2.2.2.3 Twists</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-3-Advanced-Topics"><span class="nav-number">3.</span> <span class="nav-text">2.3 Advanced Topics</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-1-Normalization"><span class="nav-number">3.1.</span> <span class="nav-text">2.3.1 Normalization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-2-Understanding-the-Exponential-Mapping"><span class="nav-number">3.2.</span> <span class="nav-text">2.3.2 Understanding the Exponential Mapping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-4-Dual-Quaternions对偶四元数"><span class="nav-number">3.3.</span> <span class="nav-text">2.3.4 Dual Quaternions对偶四元数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-5-Configuration-Space构型空间"><span class="nav-number">3.4.</span> <span class="nav-text">2.3.5 Configuration Space构型空间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-4-Using-the-Toolbox"><span class="nav-number">4.</span> <span class="nav-text">2.4 Using the Toolbox</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-3-Time-and-Motion"><span class="nav-number">5.</span> <span class="nav-text">Chapter 3 Time and Motion</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-1-Time-Varying-Pose"><span class="nav-number">6.</span> <span class="nav-text">3.1 Time-Varying Pose</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-1-Derivative-of-Pose"><span class="nav-number">6.1.</span> <span class="nav-text">3.1.1 Derivative of Pose</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-2-Transforming-Spatial-Velocities空间速度的变换"><span class="nav-number">6.2.</span> <span class="nav-text">3.1.2 Transforming Spatial Velocities空间速度的变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-3-Incremental-Rotation旋转的增量"><span class="nav-number">6.3.</span> <span class="nav-text">3.1.3 Incremental Rotation旋转的增量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-4-Incremental-Rigid-Body-Motion-刚体运动的增量"><span class="nav-number">6.4.</span> <span class="nav-text">3.1.4 Incremental Rigid-Body Motion 刚体运动的增量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-2-Accelerating-Bodies-and-Reference-Frames"><span class="nav-number">7.</span> <span class="nav-text">3.2 Accelerating Bodies and Reference Frames</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-1-Dynamics-of-Moving-Bodies动力学"><span class="nav-number">7.1.</span> <span class="nav-text">3.2.1 Dynamics of Moving Bodies动力学</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-2-Transforming-Forces-and-Torques力和力矩的变换"><span class="nav-number">7.2.</span> <span class="nav-text">3.2.2 Transforming Forces and Torques力和力矩的变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-3-Inertial-Reference-Frame惯性参考系"><span class="nav-number">7.3.</span> <span class="nav-text">3.2.3 Inertial Reference Frame惯性参考系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-3-Creating-Time-Varying-Pose"><span class="nav-number">8.</span> <span class="nav-text">3.3 Creating Time-Varying Pose</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-1-Smooth-One-Dimensional-Trajectories"><span class="nav-number">8.1.</span> <span class="nav-text">3.3.1 Smooth One-Dimensional Trajectories</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-2-Multi-Dimensional-Trajectories多维空间的轨迹规划"><span class="nav-number">8.2.</span> <span class="nav-text">3.3.2 Multi-Dimensional Trajectories多维空间的轨迹规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-3-Multi-Segment-Trajectories多段轨迹"><span class="nav-number">8.3.</span> <span class="nav-text">3.3.3 Multi-Segment Trajectories多段轨迹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-4-Interpolation-of-Orientation-in-3D"><span class="nav-number">8.4.</span> <span class="nav-text">3.3.4 Interpolation of Orientation in 3D</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-1-Direction-of-Rotation"><span class="nav-number">8.4.1.</span> <span class="nav-text">3.3.4.1 Direction of Rotation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-5-Cartesian-Motion-in-3D"><span class="nav-number">8.5.</span> <span class="nav-text">3.3.5 Cartesian Motion in 3D</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-III-Arm-Type-Robots"><span class="nav-number">9.</span> <span class="nav-text">Part III Arm-Type Robots</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-1-Forward-Kinematics"><span class="nav-number">10.</span> <span class="nav-text">7.1 Forward Kinematics</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-1-2-Dimensional-Planar-Robotic-Arms"><span class="nav-number">10.1.</span> <span class="nav-text">7.1.1 2-Dimensional (Planar) Robotic Arms</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-2-Jacobian-in-the-End-Effector-Coordinate-Frame"><span class="nav-number">10.2.</span> <span class="nav-text">8.1.2 Jacobian in the End-Effector Coordinate Frame</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-3-Analytical-Jacobian"><span class="nav-number">10.3.</span> <span class="nav-text">8.1.3 Analytical Jacobian</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-2-Jacobian-Condition-and-Manipulability雅克比条件和可操纵性"><span class="nav-number">11.</span> <span class="nav-text">8.2 Jacobian Condition and Manipulability雅克比条件和可操纵性</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SamLiu</span>

  
</div>

<div>
<a href="http://www.miitbeian.gov.cn/">陕ICP备16008972号</a> 
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'jQxFkr8U9EDRbCqLEKgx0kO1-gzGzoHsz',
        appKey: 'YCVKL4J0cJ0zfYLiUXdEopPe',
        placeholder: 'ヾﾉ≧∀≦)o Just say something.',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jQxFkr8U9EDRbCqLEKgx0kO1-gzGzoHsz", "YCVKL4J0cJ0zfYLiUXdEopPe");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>

  

  

  

  

</body>
</html>
